// üé® ai-formatting.js - M√≥dulo de Formata√ß√£o de Texto (VERS√ÉO CORRIGIDA)
// Respons√°vel por aplicar formata√ß√µes e limpezas no texto gerado pela IA

console.log("üé® M√≥dulo de Formata√ß√£o carregado (com corre√ß√£o de quebras de linha)");

// ================================================================================
// ‚úàÔ∏è FORMATA√á√ÉO DE AEROPORTOS
// ================================================================================

function formatAirports(text) {
  try {
    console.log("‚úàÔ∏è Aplicando formata√ß√£o de aeroportos...");
    
    // Remove informa√ß√µes redundantes entre par√™nteses de aeroportos
    let formatted = text
      // 1. CASOS ESPEC√çFICOS - Cidade (Aeroporto) ‚Üí Aeroporto
      // Casos complexos com duplo par√™nteses: "S√£o Paulo (Guarulhos (SP))" ‚Üí "Guarulhos"
      .replace(/S√£o Paulo\s*\(Guarulhos\s*\([^)]*\)\)/gi, 'Guarulhos')
      .replace(/S√£o Paulo\s*\(Congonhas\s*\([^)]*\)\)/gi, 'Congonhas')
      .replace(/S√£o Paulo\s*\(Viracopos\s*\([^)]*\)\)/gi, 'Viracopos')
      .replace(/Rio de Janeiro\s*\(Gale√£o\s*\([^)]*\)\)/gi, 'Gale√£o')
      .replace(/Rio de Janeiro\s*\(Santos Dumont\s*\([^)]*\)\)/gi, 'Santos Dumont')
      
      // Casos simples - Cidade (Aeroporto) ‚Üí Aeroporto
      .replace(/S√£o Paulo\s*\(Guarulhos\)/gi, 'Guarulhos')
      .replace(/S√£o Paulo\s*\(Congonhas\)/gi, 'Congonhas')  
      .replace(/S√£o Paulo\s*\(Viracopos\)/gi, 'Viracopos')
      .replace(/Rio de Janeiro\s*\(Gale√£o\)/gi, 'Gale√£o')
      .replace(/Rio de Janeiro\s*\(Santos Dumont\)/gi, 'Santos Dumont')
      
      // 2. AEROPORTOS ESPEC√çFICOS COM SIGLAS
      .replace(/Congonhas\s*\(SP\)/gi, 'Congonhas')
      .replace(/Guarulhos\s*\(SP\)/gi, 'Guarulhos')
      .replace(/Viracopos\s*\(SP\)/gi, 'Viracopos')
      .replace(/Campinas\s*Viracopos\s*\(SP\)/gi, 'Viracopos')
      
      // Aeroportos do Rio de Janeiro
      .replace(/Gale√£o\s*\(RJ\)/gi, 'Gale√£o')
      .replace(/Santos Dumont\s*\(RJ\)/gi, 'Santos Dumont')
      
      // 3. PADR√ÉO: "Cidade Aeroporto (Estado)" ‚Üí "Aeroporto"
      // Ex: "S√£o Paulo Guarulhos (SP)" ‚Üí "Guarulhos"
      .replace(/(?:S√£o Paulo|Rio de Janeiro|Bras√≠lia|Belo Horizonte|Curitiba|Salvador|Recife|Fortaleza)\s+([A-Za-z√Ä-√ø\s]+)\s*\([A-Z]{2}\)/gi, '$1')
      
      // 4. PADR√ÉO GERAL: Nome longo com sigla ‚Üí Nome principal
      .replace(/([A-Za-z√Ä-√ø]+(?:\s+[A-Za-z√Ä-√ø]+)*)\s*\([A-Z]{2,3}\)/g, function(match, nome) {
        // Se o nome tem m√∫ltiplas palavras, pega a √∫ltima (que geralmente √© o aeroporto)
        const palavras = nome.trim().split(/\s+/);
        return palavras.length > 1 ? palavras[palavras.length - 1] : palavras[0];
      })
      
      // 5. REMOVE C√ìDIGOS IATA ISOLADOS
      .replace(/\s*\([A-Z]{3}\)/g, '')
      
      // 6. CASOS ESPECIAIS DE FORMATA√á√ÉO
      .replace(/Aeroporto\s+Internacional\s+de\s+([A-Za-z√Ä-√ø\s]+)/gi, '$1')
      .replace(/Aeroporto\s+([A-Za-z√Ä-√ø\s]+)/gi, '$1')
      
      // 7. LIMPA ESPA√áOS DUPLOS E TRIM
      .replace(/\s{2,}/g, ' ')
      .trim();
    
    console.log("‚úÖ Formata√ß√£o de aeroportos aplicada");
    return formatted;
    
  } catch (error) {
    console.error("‚ùå Erro na formata√ß√£o de aeroportos:", error);
    return text;
  }
}

// ================================================================================
// üîó FILTRO DE LINKS CONDICIONAIS
// ================================================================================

function conditionalLinks(text) {
  try {
    console.log("üîó Filtrando links v√°lidos...");
    
    // 1. REMOVE PLACEHOLDERS DE LINKS GEN√âRICOS - VERS√ÉO APRIMORADA
    let formatted = text
      // Remove colchetes com diferentes tipos de texto
      .replace(/\[LINK[^\]]*\]/gi, '')
      .replace(/\[CLIQUE[^\]]*\]/gi, '')
      .replace(/\[ACESSE[^\]]*\]/gi, '')
      .replace(/\[VEJA[^\]]*\]/gi, '')
      .replace(/\[CONFIRA[^\]]*\]/gi, '')
      .replace(/\[SAIBA[^\]]*\]/gi, '')
      .replace(/\[CONSULTE[^\]]*\]/gi, '')
      .replace(/\[RESERVE[^\]]*\]/gi, '')
      
      // Remove par√°grafos gen√©ricos de link
      .replace(/.*\[LINK\s+[A-Z\s]+\].*/gi, '')
      .replace(/.*\[.*MAIS.*INFORMA√á√ïES.*\].*/gi, '')
      
      // Remove URLs quebradas ou placeholders
      .replace(/https?:\/\/www\.exemplo[^\s]*/gi, '')
      .replace(/https?:\/\/[a-z-]+\.com\.br\/exemplo[^\s]*/gi, '')
      
      // Remove texto gen√©rico de links
      .replace(/Link para mais informa√ß√µes[:.]*\s*/gi, '')
      .replace(/Clique aqui para[^\n]*/gi, '')
      .replace(/Acesse o link[^\n]*/gi, '')
      .replace(/Mais detalhes em[^\n]*/gi, '')
      .replace(/Para mais informa√ß√µes[^\n]*/gi, '');
    
    // 2. FILTRA LINHAS COM LINKS
    formatted = formatted
      .split('\n')
      .filter(line => {
        const lineTrimmed = line.trim();
        
        // Remove linhas vazias que sobraram da remo√ß√£o de links
        if (!lineTrimmed) return false;
        
        // Se a linha cont√©m "http" ou "www", verifica se √© um link v√°lido
        if (lineTrimmed.includes('http') || lineTrimmed.includes('www')) {
          // Mant√©m apenas se come√ßar com http:// ou https://
          return /https?:\/\/[a-zA-Z0-9][^\s]*\.[a-zA-Z]{2,}/.test(lineTrimmed);
        }
        
        // Remove linhas que s√£o apenas indicadores de link sem URL real
        const linkIndicators = [
          /^link:/i,
          /^url:/i,
          /^website:/i,
          /^site:/i,
          /^acesse:/i,
          /^confira:/i,
          /^veja em:/i,
          /^mais em:/i,
          /^detalhes:/i
        ];
        
        // Se a linha come√ßa com indicador de link mas n√£o tem URL v√°lida
        const temIndicadorLink = linkIndicators.some(regex => regex.test(lineTrimmed));
        if (temIndicadorLink && !/https?:\/\//.test(lineTrimmed)) {
          return false;
        }
        
        // Mant√©m todas as outras linhas
        return true;
      })
      .join('\n');
    
    // 3. REMOVE FRASES COMUNS DE PLACEHOLDER
    formatted = formatted
      .replace(/.*\[LINK PARA.*\].*/gi, '')
      .replace(/.*Para reservas, acesse.*[^http].*/gi, '')
      .replace(/.*Entre em contato.*[^http].*/gi, '')
      .replace(/.*Mais informa√ß√µes dispon√≠veis.*[^http].*/gi, '')
      .replace(/.*Consulte nosso site.*[^http].*/gi, '')
      .replace(/.*Visite nossa p√°gina.*[^http].*/gi, '');
    
    // 4. LIMPA LINHAS VAZIAS RESULTANTES
    formatted = formatted
      .split('\n')
      .filter(line => line.trim() !== '')
      .join('\n');
    
    console.log("‚úÖ Filtro de links aplicado");
    return formatted;
    
  } catch (error) {
    console.error("‚ùå Erro no filtro de links:", error);
    return text;
  }
}

// ================================================================================
// üìã LIMPEZA DE CABE√áALHOS T√âCNICOS
// ================================================================================

function cleanHeaders(text) {
  try {
    console.log("üìã Removendo cabe√ßalhos t√©cnicos...");
    
    // Lista de cabe√ßalhos t√©cnicos para remover
    const technicalHeaders = [
      'DADOS DO CLIENTE:',
      'PRODUTO SELECIONADO:',
      'INFORMA√á√ïES T√âCNICAS:',
      'DETALHES T√âCNICOS:',
      'CONFIGURA√á√ïES:',
      'PAR√ÇMETROS:',
      'SISTEMA:',
      'PROCESSAMENTO:',
      'RESULTADO:',
      'OUTPUT:',
      'INPUT:',
      'RESPOSTA:',
      'SOLICITA√á√ÉO:',
      'REQUISI√á√ÉO:',
      'OR√áAMENTO CVC ITAQUA:',
      'TIPOS SELECIONADOS:',
      'DADOS DA VIAGEM:',
      'INFORMA√á√ïES ADICIONAIS:',
      'REGRAS OBRIGAT√ìRIAS:',
      'CAMPOS OPCIONAIS:',
      'GERE O OR√áAMENTO:',
      'FORMATO PADR√ÉO:'
    ];
    
    let formatted = text;
    
    // Remove cabe√ßalhos t√©cnicos (case insensitive)
    technicalHeaders.forEach(header => {
      const regex = new RegExp(`^\\s*${header.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*$`, 'gmi');
      formatted = formatted.replace(regex, '');
    });
    
    // Remove linhas que s√£o apenas marcadores ou separadores
    formatted = formatted
      .replace(/^[-=_*]{3,}$/gm, '') // Remove linhas de separadores
      .replace(/^\s*[#*-]\s*$/gm, '') // Remove marcadores isolados
      .replace(/^\s*\.\.\.\s*$/gm, ''); // Remove "..."
    
    console.log("‚úÖ Cabe√ßalhos t√©cnicos removidos");
    return formatted;
    
  } catch (error) {
    console.error("‚ùå Erro na limpeza de cabe√ßalhos:", error);
    return text;
  }
}

// ================================================================================
// üí∞ FORMATA√á√ÉO DE PRE√áOS
// ================================================================================

function formatPrices(text) {
  try {
    console.log("üí∞ Formatando valores monet√°rios...");
    
    let formatted = text;
    
    // Normaliza diferentes formatos de R$ para "R$ 1.234,56"
    formatted = formatted
      // R$1234.56 -> R$ 1.234,56
      .replace(/R\$\s*(\d{1,3})(\d{3})\.(\d{2})/g, 'R$ $1.$2,$3')
      
      // R$1234,56 -> R$ 1.234,56
      .replace(/R\$\s*(\d{1,3})(\d{3}),(\d{2})/g, 'R$ $1.$2,$3')
      
      // R$ 1234.56 -> R$ 1.234,56
      .replace(/R\$\s+(\d{1,3})(\d{3})\.(\d{2})/g, 'R$ $1.$2,$3')
      
      // R$ 1234,56 (j√° formatado, apenas garante espa√ßo)
      .replace(/R\$(\d)/g, 'R$ $1')
      
      // Para valores maiores com mais d√≠gitos
      .replace(/R\$\s*(\d{1,3})(\d{3})(\d{3})\.(\d{2})/g, 'R$ $1.$2.$3,$4')
      .replace(/R\$\s*(\d{1,3})(\d{3})(\d{3}),(\d{2})/g, 'R$ $1.$2.$3,$4')
      
      // Corrige valores simples (R$123 -> R$ 123,00)
      .replace(/R\$\s*(\d{1,3})(?![.,\d])/g, 'R$ $1,00')
      
      // Remove espa√ßos duplos entre R$ e valor
      .replace(/R\$\s{2,}/g, 'R$ ')
      
      // ‚ú® NOVO: Corrige espa√ßos indevidos dentro dos valores
      // "R$ 6. 242, 34" ‚Üí "R$ 6.242,34"
      .replace(/R\$\s*(\d+)\.\s*(\d{3}),\s*(\d{2})/g, 'R$ $1.$2,$3')
      .replace(/R\$\s*(\d+)\.\s*(\d{3})\.\s*(\d{3}),\s*(\d{2})/g, 'R$ $1.$2.$3,$4');
    
    console.log("‚úÖ Formata√ß√£o de pre√ßos aplicada");
    return formatted;
    
  } catch (error) {
    console.error("‚ùå Erro na formata√ß√£o de pre√ßos:", error);
    return text;
  }
}

// ================================================================================
// üìè ADI√á√ÉO DE QUEBRAS DE LINHA INTELIGENTES (NOVA FUN√á√ÉO)
// ================================================================================

function addSmartLineBreaks(text) {
  try {
    console.log("üìè Adicionando quebras de linha inteligentes...");
    
    if (!text || typeof text !== 'string') {
      return text || '';
    }
    
    let formatted = text;
    
    // ETAPA 1: Padr√µes que devem ter quebra ANTES (principais emojis do or√ßamento)
    const breakBefore = [
      'üè∑Ô∏è',               // Companhia a√©rea
      'üóìÔ∏è',               // Data  
      'üí∞',               // Pre√ßo
      'üí≥',               // Condi√ß√µes de pagamento
      '‚ö†Ô∏è',               // Avisos
      'üîó',               // Links
      '‚úàÔ∏è VOO DE VOLTA',   // Se√ß√£o de volta
      '‚úàÔ∏è VOO DE IDA',     // Se√ß√£o de ida
      'üè®',               // Hot√©is
      'üìç',               // Destino
      'üë•',               // Passageiros
      'üß≥',               // Bagagem
      'üõ°Ô∏è',              // Seguro
      'üé´'                // Ingressos
    ];
    
    // ETAPA 2: Aplica quebras antes dos emojis (exceto no in√≠cio)
    breakBefore.forEach(pattern => {
      const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`(?<!^)\\s*(${escaped})`, 'g');
      formatted = formatted.replace(regex, '\n$1');
    });
    
    // ETAPA 3: Quebras duplas para se√ß√µes importantes
    const doubleBrakes = [
      '‚úàÔ∏è VOO DE VOLTA',
      'üè® OP√á√ïES DE HOT√âIS',
      'üè® HOTEL',
      'OP√á√ÉO 1',
      'OP√á√ÉO 2',
      'OP√á√ÉO 3'
    ];
    
    doubleBrakes.forEach(pattern => {
      const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`(?<!^\\n)\\s*(${escaped})`, 'g');
      formatted = formatted.replace(regex, '\n\n$1');
    });
    
    // ETAPA 4: Quebras espec√≠ficas ap√≥s informa√ß√µes de voo
    formatted = formatted
      // Quebra ap√≥s hor√°rios quando h√° emoji seguinte
      .replace(/(\d{2}:\d{2})\s+(üí∞|üí≥|üîó|‚ö†Ô∏è|üè∑Ô∏è|üóìÔ∏è)/g, '$1\n$2')
      
      // Quebra ap√≥s aeroportos/cidades quando h√° emoji seguinte
      .replace(/(Guarulhos|Salvador|Santos Dumont|Congonhas)\s+(\d{2}:\d{2})?\s*(üí∞|üí≥|üè∑Ô∏è|üóìÔ∏è)/g, '$1 $2\n$3')
      
      // Quebra antes de "VOO DE VOLTA" se n√£o tiver quebra
      .replace(/([^\n])\s*(‚úàÔ∏è VOO DE VOLTA)/g, '$1\n\n$2')
      
      // Quebra antes de "VOO DE IDA" se n√£o tiver quebra
      .replace(/([^\n])\s*(‚úàÔ∏è VOO DE IDA)/g, '$1\n\n$2');
    
    // ETAPA 5: Limpeza final
    formatted = formatted
      // Remove quebras excessivas (m√°ximo 2 seguidas)
      .replace(/\n{3,}/g, '\n\n')
      
      // Remove espa√ßos antes e depois de quebras
      .replace(/\s+\n/g, '\n')
      .replace(/\n\s+/g, '\n')
      
      // Remove quebras no in√≠cio e fim
      .replace(/^\n+/, '')
      .replace(/\n+$/, '');
    
    const originalLines = (text.match(/\n/g) || []).length;
    const formattedLines = (formatted.match(/\n/g) || []).length;
    
    console.log(`üìä Quebras de linha: ${originalLines} ‚Üí ${formattedLines}`);
    console.log("‚úÖ Quebras de linha inteligentes aplicadas");
    
    return formatted;
    
  } catch (error) {
    console.error("‚ùå Erro ao adicionar quebras de linha:", error);
    return text;
  }
}

// ================================================================================
// üìè OTIMIZA√á√ÉO DE ESPA√áAMENTO (PRESERVANDO QUEBRAS)
// ================================================================================

function optimizeSpacing(text) {
  try {
    console.log("üìè Otimizando espa√ßamento (preservando quebras)...");
    
    let formatted = text
      // 1. FORMATA√á√ÉO DE HOR√ÅRIOS: "23: 30" ‚Üí "23:30", "8 : 15" ‚Üí "08:15"
      .replace(/(\d{1,2})\s*:\s*(\d{2})/g, (match, horas, minutos) => {
        // Adiciona zero √† esquerda se necess√°rio
        const h = horas.padStart(2, '0');
        const m = minutos.padStart(2, '0');
        return `${h}:${m}`;
      })
      
      // 2. FORMATA√á√ÉO DE DATAS: "17 / 01" ‚Üí "17/01"
      .replace(/(\d{1,2})\s*\/\s*(\d{1,2})/g, '$1/$2')
      
      // 3. ‚ö†Ô∏è PRESERVA quebras de linha (n√£o remove)
      // .replace(/\n{3,}/g, '\n\n') // COMENTADO para preservar quebras inteligentes
      
      // 4. Remove espa√ßos no final das linhas
      .replace(/[ \t]+$/gm, '')
      
      // 5. Remove espa√ßos no in√≠cio das linhas (exceto indenta√ß√£o intencional)
      .replace(/^[ \t]+/gm, '')
      
      // 6. Normaliza espa√ßos entre palavras
      .replace(/[ \t]{2,}/g, ' ')
      
      // 7. Remove apenas linhas vazias no in√≠cio e fim (preserva quebras internas)
      .replace(/^\n+/, '')
      .replace(/\n+$/, '')
      
      // 8. CORRE√á√ÉO DE PONTUA√á√ÉO
      // Garante que n√£o h√° espa√ßos antes de pontua√ß√£o
      .replace(/\s+([.,!?;:])/g, '$1')
      
      // Garante espa√ßo ap√≥s pontua√ß√£o (exceto no final da linha)
      .replace(/([.,!?;:])(?=[^\s\n])/g, '$1 ')
      
      // 9. CORRE√á√ÉO DE PAR√äNTESES
      // Remove espa√ßos antes de par√™nteses de fechamento
      .replace(/\s+\)/g, ')')
      
      // Remove espa√ßos desnecess√°rios ap√≥s par√™nteses de abertura
      .replace(/\(\s+/g, '(')
      
      // 10. FORMATA√á√ÉO DE SETAS E CONECTORES
      // Padroniza setas: "‚Üí", "->", " ‚Üí " para " ‚Üí "
      .replace(/\s*[-=]+>\s*/g, ' ‚Üí ')
      .replace(/\s*‚Üí\s*/g, ' ‚Üí ')
      
      // 11. FORMATA√á√ÉO DE H√çFENS
      // H√≠fens em intervalos: " - " (com espa√ßos)
      .replace(/\s*-\s*/g, ' - ')
      
      // 12. FORMATA√á√ÉO DE VALORES MONET√ÅRIOS APRIMORADA
      // "R$ 1.234 , 56" ‚Üí "R$ 1.234,56"
      .replace(/(R\$\s*[\d.]+)\s*,\s*(\d{2})/g, '$1,$2')
      
      // "R$1.234,56" ‚Üí "R$ 1.234,56" (garante espa√ßo ap√≥s R$)
      .replace(/R\$(\d)/g, 'R$ $1')
      
      // Corrige espa√ßos excessivos em valores: "R$  1.234" ‚Üí "R$ 1.234"
      .replace(/R\$\s{2,}/g, 'R$ ')
      
      // Valores sem v√≠rgula: "R$ 1234" ‚Üí "R$ 1.234,00" (valores acima de 999)
      .replace(/R\$\s*(\d{1,3})(\d{3})(?![,.])/g, 'R$ $1.$2,00')
      
      // 13. CORRE√á√ÉO DE ESPA√áOS EM C√ìDIGOS
      // "CGH ‚Üí GRU" mant√©m formata√ß√£o correta
      .replace(/([A-Z]{3})\s*‚Üí\s*([A-Z]{3})/g, '$1 ‚Üí $2');
    
    // ‚ö†Ô∏è IMPORTANTE: N√ÉO remove quebras m√∫ltiplas para preservar formata√ß√£o inteligente
    
    console.log("‚úÖ Espa√ßamento otimizado (quebras preservadas)");
    return formatted.trim();
    
  } catch (error) {
    console.error("‚ùå Erro na otimiza√ß√£o de espa√ßamento:", error);
    return text;
  }
}

// ================================================================================
// üéØ FUN√á√ÉO PRINCIPAL DE FORMATA√á√ÉO (CORRIGIDA)
// ================================================================================

function formatText(text) {
  try {
    console.log("üéØ Iniciando formata√ß√£o completa do texto...");
    
    if (!text || typeof text !== 'string') {
      console.warn("‚ö†Ô∏è Texto inv√°lido para formata√ß√£o");
      return text || '';
    }
    
    // ETAPA 1: AN√ÅLISE PR√âVIA (antes de modificar o texto)
    // Preserva informa√ß√µes importantes para detec√ß√£o de ida/volta
    const textoOriginal = text.toLowerCase();
    let isIdaVolta = false;
    
    // Verifica se tem detec√ß√£o de ida e volta dispon√≠vel
    if (typeof detectarIdaVolta === 'function') {
      isIdaVolta = detectarIdaVolta(textoOriginal);
      console.log(`üîç Detec√ß√£o ida/volta: ${isIdaVolta ? 'SIM' : 'N√ÉO'}`);
    }
    
    // ETAPA 2: FORMATA√á√ïES SEQUENCIAIS
    let formatted = text;
    
    // Aplica formata√ß√µes b√°sicas primeiro
    formatted = formatAirports(formatted);
    formatted = conditionalLinks(formatted);  
    formatted = cleanHeaders(formatted);
    formatted = formatPrices(formatted);
    
    // ‚ú® NOVO: Adiciona quebras de linha inteligentes
    formatted = addSmartLineBreaks(formatted);
    
    // Otimiza√ß√£o de espa√ßamento por √∫ltimo (mas preservando quebras)
    formatted = optimizeSpacing(formatted);
    
    // ETAPA 3: INFORMA√á√ïES DE DEBUG (apenas em desenvolvimento)
    if (typeof window !== 'undefined' && window.location.hostname === 'localhost') {
      console.log("üìä Resultado da formata√ß√£o:");
      console.log(`   Texto original: ${text.length} caracteres`);
      console.log(`   Texto formatado: ${formatted.length} caracteres`);
      console.log(`   Ida e volta detectado: ${isIdaVolta ? 'SIM' : 'N√ÉO'}`);
      console.log(`   Quebras de linha: ${(formatted.match(/\n/g) || []).length}`);
    }
    
    console.log("‚úÖ Formata√ß√£o completa aplicada (com quebras de linha)");
    
    return formatted;
    
  } catch (error) {
    console.error("‚ùå Erro na formata√ß√£o completa:", error);
    return text;
  }
}

// ================================================================================
// üß™ FUN√á√ÉO DE TESTE PARA FORMATA√á√ÉO COMPLETA
// ================================================================================

function testarFormatacaoCompleta() {
  console.log("üß™ Testando formata√ß√£o completa (com quebras de linha)...");
  
  const textoTeste = `‚úàÔ∏è VOO DE IDA üè∑Ô∏è LATAM üóìÔ∏è 17 de janeiro ‚úàÔ∏è 23: 30 - Guarulhos 01: 50 / Salvador üí∞ R$ 6. 242, 34 para 2 Adultos e 1 Crian√ßa üí≥ N√£o reembols√°vel ‚úàÔ∏è VOO DE VOLTA üè∑Ô∏è LATAM üóìÔ∏è 23 de janeiro ‚úàÔ∏è 20: 55 - Salvador 23: 30 / Guarulhos üí∞ R$ 6. 242, 34 para 2 Adultos e 1 Crian√ßa üí≥ N√£o reembols√°vel`;

  console.log("üì• TEXTO ORIGINAL (sem quebras):");
  console.log(textoTeste);
  console.log(`Quebras originais: ${(textoTeste.match(/\n/g) || []).length}`);

  const resultado = formatText(textoTeste);
  
  console.log("üì§ TEXTO FORMATADO (com quebras):");
  console.log(resultado);
  console.log(`Quebras finais: ${(resultado.match(/\n/g) || []).length}`);
  
  // Verifica√ß√µes espec√≠ficas
  const verificacoes = [
    {
      nome: "Quebras de linha adicionadas",
      teste: (resultado.match(/\n/g) || []).length >= 8,
      esperado: true
    },
    {
      nome: "Hor√°rios formatados",
      teste: !resultado.includes("23: 30") && resultado.includes("23:30"),
      esperado: true
    },
    {
      nome: "Pre√ßos formatados",
      teste: resultado.includes("R$ 6.242,34") && !resultado.includes("R$ 6. 242, 34"),
      esperado: true
    },
    {
      nome: "Se√ß√µes separadas",
      teste: resultado.includes("‚úàÔ∏è VOO DE IDA") && resultado.includes("‚úàÔ∏è VOO DE VOLTA"),
      esperado: true
    },
    {
      nome: "Emojis preservados",
      teste: resultado.includes("üè∑Ô∏è") && resultado.includes("üóìÔ∏è") && resultado.includes("üí∞"),
      esperado: true
    }
  ];
  
  let acertos = 0;
  verificacoes.forEach(verificacao => {
    const passou = verificacao.teste === verificacao.esperado;
    console.log(`${passou ? '‚úÖ' : '‚ùå'} ${verificacao.nome}`);
    if (passou) acertos++;
  });
  
  console.log(`\nüìä Resultado: ${acertos}/${verificacoes.length} testes passaram`);
  
  if (acertos === verificacoes.length) {
    console.log("üéâ SUCESSO! Formata√ß√£o com quebras de linha funcionando!");
  } else {
    console.log("‚ö†Ô∏è Alguns testes falharam. Verifique a implementa√ß√£o.");
  }
  
  return { acertos, total: verificacoes.length, resultado };
}

// ================================================================================
// üß™ TESTE ESPEC√çFICO DE QUEBRAS DE LINHA
// ================================================================================

function testarQuebrasLinha() {
  console.log("üß™ === TESTE ESPEC√çFICO DE QUEBRAS DE LINHA ===");
  
  const textoSemQuebras = `‚úàÔ∏è VOO DE IDA üè∑Ô∏è LATAM üóìÔ∏è 17 de janeiro ‚úàÔ∏è 23:30 - Guarulhos 01:50 / Salvador üí∞ R$ 6.242,34 para 2 Adultos e 1 Crian√ßa üí≥ N√£o reembols√°vel ‚úàÔ∏è VOO DE VOLTA üè∑Ô∏è LATAM üóìÔ∏è 23 de janeiro ‚úàÔ∏è 20:55 - Salvador 23:30 / Guarulhos üí∞ R$ 6.242,34 para 2 Adultos e 1 Crian√ßa üí≥ N√£o reembols√°vel`;
  
  console.log("üì• ANTES (uma linha s√≥):");
  console.log(textoSemQuebras);
  console.log(`Quebras: ${(textoSemQuebras.match(/\n/g) || []).length}`);
  
  const resultado = addSmartLineBreaks(textoSemQuebras);
  
  console.log("\nüì§ DEPOIS (com quebras):");
  console.log(resultado);
  console.log(`Quebras: ${(resultado.match(/\n/g) || []).length}`);
  
  console.log("üß™ === FIM DO TESTE ===");
  
  return resultado;
}

// ================================================================================
// üì§ EXPORTA√á√ÉO COMPAT√çVEL COM SISTEMA CVC
// ================================================================================

// Compatibilidade com sistema de m√≥dulos existente
if (typeof window !== 'undefined') {
  // Browser environment - adiciona ao objeto global
  window.formatText = formatText;
  window.formatAirports = formatAirports;
  window.conditionalLinks = conditionalLinks;
  window.cleanHeaders = cleanHeaders;
  window.formatPrices = formatPrices;
  window.optimizeSpacing = optimizeSpacing;
  window.addSmartLineBreaks = addSmartLineBreaks;
  window.testarQuebrasLinha = testarQuebrasLinha;
}

// Exporta√ß√£o para sistemas que suportam modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    formatText,
    formatAirports,
    conditionalLinks,
    cleanHeaders,
    formatPrices,
    optimizeSpacing,
    addSmartLineBreaks,
    testarQuebrasLinha
  };
}

// ================================================================================
// üöÄ EXECU√á√ÉO AUTOM√ÅTICA DE TESTES EM DESENVOLVIMENTO
// ================================================================================

// Executar teste automaticamente em desenvolvimento
if (typeof window !== 'undefined' && window.location.hostname === 'localhost') {
  // Aguarda 2 segundos para carregar completamente e depois testa
  setTimeout(() => {
    console.log("\nüß™ === TESTES AUTOM√ÅTICOS DO AI-FORMATTING (CORRIGIDO) ===");
    testarFormatacaoCompleta();
    console.log("\nüß™ === TESTE DE QUEBRAS DE LINHA ===");
    testarQuebrasLinha();
    console.log("üß™ === FIM DOS TESTES ===\n");
  }, 2000);
}

console.log("‚úÖ M√≥dulo ai-formatting.js carregado e corrigido (com quebras de linha)");
