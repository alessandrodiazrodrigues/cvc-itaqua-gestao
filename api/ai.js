// üöÄ api/ai.js - SISTEMA BACKEND CVC ITAQUA v7.1 - CORRE√á√ÉO COMPLETA
// Corre√ß√£o da incompatibilidade frontend/backend + Sistema modular completo
// Aceita m√∫ltiplos formatos + Debug permanente + Arquitetura limpa

export default async function handler(req, res) {
  console.log("üöÄ CVC ITAQUA API v7.1 - Processando requisi√ß√£o");
  console.log("üìä M√©todo:", req.method, "| Timestamp:", new Date().toISOString());

  // Configurar CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      error: 'M√©todo n√£o permitido',
      versao: '7.1'
    });
  }

  try {
    console.log("üì• Dados recebidos:");
    console.log("- Body existe:", !!req.body);
    console.log("- Body completo:", JSON.stringify(req.body, null, 2));

    // ============================================================================
    // üîß COMPATIBILIDADE: ACEITAR M√öLTIPLOS FORMATOS DE DADOS
    // ============================================================================
    
    let formData, tipo, versao;
    
    // FORMATO NOVO (v7.0+): { formData: {...}, tipo: 'orcamento', versao: '7.0' }
    if (req.body.formData && req.body.tipo) {
      console.log("üìç Formato novo detectado (v7.0+)");
      formData = req.body.formData;
      tipo = req.body.tipo;
      versao = req.body.versao || '7.1';
    }
    
    // FORMATO ANTIGO (v6.x): dados diretos no body
    else if (req.body.tipos || req.body.prompt || req.body.observacoes) {
      console.log("üìç Formato antigo detectado (v6.x) - Convertendo...");
      formData = req.body;
      
      // Determinar tipo baseado nos dados
      if (formData.tipos && formData.tipos.length > 0) {
        tipo = 'orcamento';
      } else if (formData.prompt?.includes('ranking') || formData.prompt?.includes('hotel')) {
        tipo = 'ranking';
      } else if (formData.prompt?.includes('dica') || formData.prompt?.includes('destino')) {
        tipo = 'dicas';
      } else {
        tipo = 'orcamento'; // Padr√£o
      }
      
      versao = '6.x-convertido';
    }
    
    // FORMATO INV√ÅLIDO
    else {
      console.error("‚ùå Formato de dados n√£o reconhecido");
      throw new Error("Formato de dados n√£o reconhecido. Envie 'formData' e 'tipo' ou dados no formato v6.x");
    }

    // ============================================================================
    // üîß NORMALIZA√á√ÉO DOS DADOS
    // ============================================================================
    
    // Garantir que 'tipos' seja sempre um array
    if (formData.tipos) {
      if (typeof formData.tipos === 'string') {
        formData.tipos = [formData.tipos];
      }
    } else if (formData.tipo) {
      formData.tipos = [formData.tipo];
    } else {
      formData.tipos = ['A√©reo Nacional']; // Padr√£o
    }

    console.log("üéØ Dados normalizados:");
    console.log("- Tipo opera√ß√£o:", tipo);
    console.log("- Tipos or√ßamento:", formData.tipos);
    console.log("- Tem imagem:", !!formData.temImagem);
    console.log("- Destino:", formData.destino);

    // ============================================================================
    // üéØ VALIDA√á√ïES MELHORADAS
    // ============================================================================
    
    if (!formData) {
      throw new Error("Dados do formul√°rio n√£o encontrados");
    }

    if (!formData.tipos || formData.tipos.length === 0) {
      throw new Error("Pelo menos um tipo de or√ßamento deve ser selecionado");
    }

    // ============================================================================
    // ü§ñ PROCESSAMENTO BASEADO NO TIPO
    // ============================================================================
    
    let resultado;
    switch (tipo) {
      case 'orcamento':
        resultado = await processarOrcamento(formData);
        break;
      case 'ranking':
        resultado = await processarRanking(formData);
        break;
      case 'dicas':
        resultado = await processarDicas(formData);
        break;
      case 'analise':
        resultado = await processarAnalise(formData);
        break;
      default:
        throw new Error(`Tipo de opera√ß√£o n√£o suportado: ${tipo}`);
    }

    console.log("‚úÖ Processamento conclu√≠do com sucesso");
    
    return res.status(200).json({
      success: true,
      result: resultado,
      versao: '7.1',
      timestamp: new Date().toISOString(),
      debug: {
        tipoOperacao: tipo,
        tiposOrcamento: formData.tipos,
        temImagem: !!formData.temImagem,
        formatoDetectado: versao
      }
    });

  } catch (error) {
    console.error("‚ùå Erro no processamento:", error);
    
    return res.status(500).json({
      success: false,
      error: error.message,
      versao: '7.1',
      timestamp: new Date().toISOString(),
      debug: {
        bodyReceived: req.body ? Object.keys(req.body) : null,
        errorStack: error.stack?.split('\n')[0]
      }
    });
  }
}

// ================================================================================
// üéØ PROCESSADORES ESPECIALIZADOS
// ================================================================================

async function processarOrcamento(formData) {
  console.log("üéØ Iniciando processamento de or√ßamento...");
  
  // ETAPA 1: An√°lise completa dos dados
  const analise = analisarTextoCompleto(formData);
  console.log("üìä An√°lise:", analise);
  
  // ETAPA 2: Selecionar template otimizado
  const template = selecionarTemplate(formData, analise);
  console.log("üìã Template selecionado:", template.tipo);
  
  // ETAPA 3: Gerar prompt final
  const prompt = construirPromptFinal(formData, analise, template);
  
  // ETAPA 4: Determinar melhor modelo
  const modelo = determinarModelo(analise.complexidade);
  console.log("ü§ñ Modelo selecionado:", modelo);
  
  // ETAPA 5: Chamar IA
  try {
    const resposta = await chamarIA(prompt, modelo, formData.temImagem, formData.arquivo);
    
    // ETAPA 6: Processar resposta
    const resultado = processarResposta(resposta, analise);
    
    // ETAPA 7: Calcular e registrar custos
    await registrarCustos(prompt, resposta, modelo, formData.destino);
    
    return resultado;
  } catch (error) {
    console.error("‚ùå Erro ao processar or√ßamento:", error);
    throw new Error(`Erro na gera√ß√£o do or√ßamento: ${error.message}`);
  }
}

async function processarRanking(formData) {
  console.log("üè® Processando ranking de hot√©is...");
  
  try {
    const prompt = construirPromptRanking(formData.destino || 'destino solicitado');
    const resposta = await chamarIA(prompt, 'gpt-4o-mini');
    
    await registrarCustos(prompt, resposta, 'gpt-4o-mini', formData.destino);
    
    return resposta;
  } catch (error) {
    console.error("‚ùå Erro ao processar ranking:", error);
    throw new Error(`Erro na gera√ß√£o do ranking: ${error.message}`);
  }
}

async function processarDicas(formData) {
  console.log("üí° Processando dicas de destino...");
  
  try {
    const prompt = construirPromptDicas(formData.destino || 'destino solicitado');
    const resposta = await chamarIA(prompt, 'gpt-4o-mini');
    
    await registrarCustos(prompt, resposta, 'gpt-4o-mini', formData.destino);
    
    return resposta;
  } catch (error) {
    console.error("‚ùå Erro ao processar dicas:", error);
    throw new Error(`Erro na gera√ß√£o das dicas: ${error.message}`);
  }
}

async function processarAnalise(formData) {
  console.log("üìÑ Processando an√°lise de PDF...");
  
  try {
    const prompt = construirPromptAnalise(formData);
    const resposta = await chamarIA(prompt, 'gpt-4o', formData.temImagem, formData.arquivo);
    
    await registrarCustos(prompt, resposta, 'gpt-4o', 'An√°lise PDF');
    
    return resposta;
  } catch (error) {
    console.error("‚ùå Erro ao processar an√°lise:", error);
    throw new Error(`Erro na an√°lise do PDF: ${error.message}`);
  }
}

// ================================================================================
// üß† SISTEMA DE AN√ÅLISE INTELIGENTE
// ================================================================================

function analisarTextoCompleto(formData) {
  const textoCompleto = `${formData.observacoes || ''} ${formData.textoColado || ''} ${formData.prompt || ''}`.trim();
  
  console.log("üîç Analisando texto completo...");
  console.log("üìè Tamanho do texto:", textoCompleto.length, "caracteres");
  
  // An√°lise de m√∫ltiplas op√ß√µes
  const multiplasOpcoes = detectarMultiplasOpcoes(textoCompleto);
  
  // An√°lise de ida e volta
  const idaVolta = detectarIdaVolta(textoCompleto);
  
  // An√°lise de complexidade
  const complexidade = calcularComplexidade(textoCompleto, formData);
  
  // An√°lise de tipo espec√≠fico
  const tipoEspecifico = detectarTipoEspecifico(formData.tipos, textoCompleto);
  
  return {
    multiplasOpcoes,
    idaVolta,
    complexidade,
    tipoEspecifico,
    temImagem: formData.temImagem || false,
    tamanhoTexto: textoCompleto.length
  };
}

function detectarMultiplasOpcoes(texto) {
  const indicadores = [
    /op√ß√£o\s+\d+/gi,
    /alternativa\s+\d+/gi,
    /\d+¬∫?\s*-\s*(voo|passagem)/gi,
    /r\$\s*\d+[\.,]\d+.*r\$\s*\d+[\.,]\d+/gi
  ];
  
  const deteccoes = indicadores.map(regex => (texto.match(regex) || []).length);
  const total = deteccoes.reduce((a, b) => a + b, 0);
  
  return {
    detectado: total >= 2,
    quantidade: Math.max(...deteccoes, 1),
    confianca: Math.min(total / 4, 1)
  };
}

function detectarIdaVolta(texto) {
  const indicadoresIda = /\b(ida|sa√≠da|partida|embarque)\b/gi;
  const indicadoresVolta = /\b(volta|retorno|chegada|regresso)\b/gi;
  
  const temIda = indicadoresIda.test(texto);
  const temVolta = indicadoresVolta.test(texto);
  
  // Detectar datas diferentes
  const datas = texto.match(/\d{1,2}\/\d{1,2}(?:\/\d{2,4})?/g) || [];
  const datasUnicas = [...new Set(datas)];
  
  return {
    detectado: (temIda && temVolta) || datasUnicas.length >= 2,
    temIndicadores: temIda && temVolta,
    quantidadeDatas: datasUnicas.length
  };
}

function calcularComplexidade(texto, formData) {
  let pontos = 0;
  
  // Fatores de complexidade
  if (texto.length > 500) pontos += 2;
  if (formData.tipos && formData.tipos.length > 1) pontos += 1;
  if (formData.temImagem) pontos += 1;
  if (detectarMultiplasOpcoes(texto).detectado) pontos += 2;
  if ((texto.match(/\d{2}:\d{2}/g) || []).length > 4) pontos += 1;
  if ((texto.match(/[A-Z]{3}/g) || []).length > 2) pontos += 1;
  
  if (pontos <= 2) return 'simples';
  if (pontos <= 5) return 'media';
  return 'alta';
}

function detectarTipoEspecifico(tipos, texto) {
  const deteccoes = {
    cruzeiro: /\b(cruzeiro|navio|msc|costa)\b/gi.test(texto),
    hotel: /\b(hotel|resort|pousada|hostel)\b/gi.test(texto),
    aereo: /\b(voo|passagem|a√©reo|airline)\b/gi.test(texto),
    pacote: /\b(pacote|combo|all inclusive)\b/gi.test(texto)
  };
  
  const tipoDetectado = Object.keys(deteccoes).find(tipo => deteccoes[tipo]);
  
  return {
    principal: tipoDetectado || 'aereo',
    deteccoes,
    baseadoEm: tipoDetectado ? 'texto' : 'tipos_selecionados'
  };
}

// ================================================================================
// üìã SISTEMA DE TEMPLATES OTIMIZADO
// ================================================================================

function selecionarTemplate(formData, analise) {
  console.log("üìã Selecionando template otimizado...");
  
  // Prioridade 1: Cruzeiros
  if (analise.tipoEspecifico.principal === 'cruzeiro' || 
      formData.tipos.some(t => t.toLowerCase().includes('cruzeiro'))) {
    return { tipo: 'cruzeiro', template: TEMPLATE_CRUZEIRO };
  }
  
  // Prioridade 2: M√∫ltiplas op√ß√µes
  if (analise.multiplasOpcoes.detectado) {
    return { tipo: 'multiplas_opcoes', template: TEMPLATE_MULTIPLAS_OPCOES };
  }
  
  // Prioridade 3: Ida e volta
  if (analise.idaVolta.detectado) {
    return { tipo: 'ida_volta', template: TEMPLATE_IDA_VOLTA };
  }
  
  // Prioridade 4: Hotel
  if (analise.tipoEspecifico.principal === 'hotel' || 
      formData.tipos.some(t => t.toLowerCase().includes('hotel'))) {
    return { tipo: 'hotel', template: TEMPLATE_HOTEL };
  }
  
  // Template padr√£o
  return { tipo: 'ida_volta', template: TEMPLATE_IDA_VOLTA };
}

// Templates espec√≠ficos
const TEMPLATE_IDA_VOLTA = `
OR√áAMENTO CVC ITAQUAQUECETUBA - IDA E VOLTA

DADOS DA VIAGEM:
{dadosViagem}

INSTRU√á√ïES ESPEC√çFICAS:
1. üîç ESTRUTURA OBRIGAT√ìRIA:
   - Se√ß√£o "‚úàÔ∏è VOO DE IDA" com data, hor√°rio e aeroportos
   - Se√ß√£o "‚úàÔ∏è VOO DE VOLTA" com data, hor√°rio e aeroportos
   - Separar claramente as duas se√ß√µes

2. ‚úàÔ∏è AEROPORTOS:
   - Converter c√≥digos para nomes completos
   - Ida: Origem ‚Üí Destino (com escalas se houver)
   - Volta: Destino ‚Üí Origem (com escalas se houver)

3. üí∞ PRE√áOS:
   - Total por pessoa
   - Total fam√≠lia (se m√∫ltiplos passageiros)
   - Usar apenas valores reais fornecidos

4. üßπ FORMATA√á√ÉO:
   - Sem cabe√ßalhos t√©cnicos
   - Pronto para WhatsApp
   - Emojis apropriados

GERE O OR√áAMENTO PROFISSIONAL:
`;

const TEMPLATE_MULTIPLAS_OPCOES = `
OR√áAMENTO CVC ITAQUAQUECETUBA - M√öLTIPLAS OP√á√ïES

DADOS DA VIAGEM:
{dadosViagem}

INSTRU√á√ïES ESPEC√çFICAS:
1. üî¢ NUMERA√á√ÉO CLARA:
   - "OP√á√ÉO 1:", "OP√á√ÉO 2:", etc.
   - Separar cada op√ß√£o visualmente
   - Apresentar TODAS as op√ß√µes encontradas

2. ‚úàÔ∏è PARA CADA OP√á√ÉO:
   - Aeroportos e hor√°rios espec√≠ficos
   - Companhia a√©rea
   - Escalas (se houver)
   - Pre√ßo individual

3. üí∞ COMPARA√á√ÉO DE PRE√áOS:
   - Apresentar op√ß√µes do menor para maior pre√ßo
   - Total por pessoa para cada op√ß√£o
   - Destacar melhor custo-benef√≠cio

GERE O COMPARATIVO COMPLETO:
`;

const TEMPLATE_CRUZEIRO = `
OR√áAMENTO CVC ITAQUAQUECETUBA - CRUZEIRO

DADOS DA VIAGEM:
{dadosViagem}

INSTRU√á√ïES ESPEC√çFICAS:
1. üö¢ INFORMA√á√ïES DO NAVIO:
   - Nome do navio e companhia
   - Categoria da cabine
   - Datas de embarque e desembarque

2. üó∫Ô∏è ITINER√ÅRIO:
   - Portos de parada
   - Dias em cada destino
   - Atividades principais

3. üçΩÔ∏è INCLUSO NO PACOTE:
   - Refei√ß√µes
   - Entretenimento
   - Servi√ßos inclusos

GERE O OR√áAMENTO DE CRUZEIRO:
`;

const TEMPLATE_HOTEL = `
OR√áAMENTO CVC ITAQUAQUECETUBA - HOTEL

DADOS DA VIAGEM:
{dadosViagem}

INSTRU√á√ïES ESPEC√çFICAS:
1. üè® DETALHES DO HOTEL:
   - Nome exato e categoria
   - Localiza√ß√£o e regi√£o
   - Tipo de acomoda√ß√£o

2. üõèÔ∏è SERVI√áOS INCLUSOS:
   - Tipo de pens√£o
   - Facilidades do hotel
   - Atividades dispon√≠veis

3. üí∞ VALORES:
   - Pre√ßo por di√°ria
   - Total da estadia
   - Taxas e impostos

GERE O OR√áAMENTO HOTELEIRO:
`;

// ================================================================================
// ü§ñ SISTEMA DE IA DUAL (OpenAI + Claude)
// ================================================================================

function determinarModelo(complexidade) {
  switch (complexidade) {
    case 'simples':
      return 'gpt-4o-mini';
    case 'media':
      return 'gpt-4o-mini';
    case 'alta':
      return 'gpt-4o';
    default:
      return 'gpt-4o-mini';
  }
}

function construirPromptFinal(formData, analise, template) {
  const dadosViagem = formatarDadosViagem(formData);
  const promptBase = template.template.replace('{dadosViagem}', dadosViagem);
  
  return promptBase;
}

function formatarDadosViagem(formData) {
  return `
Destino: ${formData.destino || 'N√£o informado'}
Adultos: ${formData.adultos || '2'}
Crian√ßas: ${formData.criancas || '0'}${formData.idades ? ` (idades: ${formData.idades} anos)` : ''}
Tipos selecionados: ${formData.tipos?.join(', ') || 'N√£o especificado'}

OBSERVA√á√ïES:
${formData.observacoes || 'Nenhuma observa√ß√£o fornecida'}

${formData.textoColado ? `INFORMA√á√ïES COLADAS:
${formData.textoColado}` : ''}

${formData.prompt ? `PROMPT ADICIONAL:
${formData.prompt}` : ''}
`;
}

function construirPromptRanking(destino) {
  return `Crie um ranking dos 5 melhores hot√©is em ${destino} para fam√≠lias.

Formato:
üèÜ 1. Nome do Hotel - ‚≠ê‚≠ê‚≠ê‚≠ê
üìç Regi√£o/Localiza√ß√£o
üí∞ Faixa de pre√ßo aproximada
‚≠ê Principais diferenciais

Use informa√ß√µes realistas e atuais.`;
}

function construirPromptDicas(destino) {
  return `Gere dicas personalizadas de viagem para ${destino}, focadas em fam√≠lias.

Incluir:
üå°Ô∏è Melhor √©poca para visitar
üéØ Atra√ß√µes imperd√≠veis para crian√ßas
üçΩÔ∏è Gastronomia local
üí° Dicas importantes de seguran√ßa e sa√∫de

Seja pr√°tico e direto.`;
}

function construirPromptAnalise(formData) {
  return `Analise este relat√≥rio da CVC e extraia:

1. üìä Principais m√©tricas de vendas
2. üéØ Metas vs realizado  
3. üèÜ Produtos mais vendidos
4. üìà Tend√™ncias identificadas
5. üí° Recomenda√ß√µes para melhoria

Arquivo: ${formData.nomeArquivo || 'Documento enviado'}
Seja objetivo e direto nas conclus√µes.`;
}

// ================================================================================
// ü§ñ CLIENTE DE IA UNIFICADO
// ================================================================================

async function chamarIA(prompt, modelo, temImagem = false, arquivo = null) {
  console.log(`ü§ñ Chamando ${modelo}... (Imagem: ${temImagem ? 'Sim' : 'N√£o'})`);
  
  try {
    if (modelo.startsWith('gpt')) {
      return await chamarOpenAI(prompt, modelo, temImagem, arquivo);
    } else if (modelo.startsWith('claude')) {
      return await chamarClaude(prompt, modelo, temImagem, arquivo);
    } else {
      throw new Error(`Modelo n√£o suportado: ${modelo}`);
    }
  } catch (error) {
    console.error(`‚ùå Erro ao chamar ${modelo}:`, error);
    
    // Fallback para modelo alternativo
    if (modelo !== 'gpt-4o-mini') {
      console.log("üîÑ Tentando fallback para gpt-4o-mini...");
      return await chamarOpenAI(prompt, 'gpt-4o-mini', false, null);
    }
    
    throw error;
  }
}

async function chamarOpenAI(prompt, modelo, temImagem = false, arquivo = null) {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OPENAI_API_KEY n√£o configurada');
  }

  let messages;
  
  if (temImagem && arquivo) {
    messages = [{
      role: 'user',
      content: [
        { type: 'text', text: prompt },
        { type: 'image_url', image_url: { url: arquivo } }
      ]
    }];
  } else {
    messages = [{
      role: 'user',
      content: prompt
    }];
  }

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model: modelo,
      messages: messages,
      max_tokens: modelo === 'gpt-4o' ? 4000 : 2000,
      temperature: 0.7
    })
  });

  if (!response.ok) {
    const errorData = await response.text();
    throw new Error(`OpenAI Error ${response.status}: ${errorData.substring(0, 200)}`);
  }

  const data = await response.json();
  
  if (!data.choices?.[0]?.message?.content) {
    throw new Error("Resposta inv√°lida da OpenAI");
  }

  return data.choices[0].message.content;
}

async function chamarClaude(prompt, modelo, temImagem = false, arquivo = null) {
  if (!process.env.ANTHROPIC_API_KEY) {
    throw new Error('ANTHROPIC_API_KEY n√£o configurada');
  }

  let content;
  
  if (temImagem && arquivo) {
    // Extrair base64 da URL data:
    const base64Data = arquivo.split(',')[1];
    const mediaType = arquivo.split(':')[1].split(';')[0];
    
    content = [
      { type: 'text', text: prompt },
      {
        type: 'image',
        source: {
          type: 'base64',
          media_type: mediaType,
          data: base64Data
        }
      }
    ];
  } else {
    content = [{ type: 'text', text: prompt }];
  }

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': process.env.ANTHROPIC_API_KEY,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model: modelo,
      max_tokens: 2000,
      messages: [{
        role: 'user',
        content: content
      }]
    })
  });

  if (!response.ok) {
    const errorData = await response.text();
    throw new Error(`Claude Error ${response.status}: ${errorData.substring(0, 200)}`);
  }

  const data = await response.json();
  
  if (!data.content?.[0]?.text) {
    throw new Error("Resposta inv√°lida do Claude");
  }

  return data.content[0].text;
}

// ================================================================================
// üìä PROCESSAMENTO DE RESPOSTA
// ================================================================================

function processarResposta(resposta, analise) {
  console.log("üìä Processando resposta da IA...");
  
  // Aplicar formata√ß√£o espec√≠fica baseada na an√°lise
  let respostaProcessada = resposta;
  
  // Limpeza b√°sica
  respostaProcessada = respostaProcessada.trim();
  
  // Aplicar regras de formata√ß√£o espec√≠ficas
  if (analise.multiplasOpcoes.detectado) {
    respostaProcessada = formatarMultiplasOpcoes(respostaProcessada);
  }
  
  if (analise.idaVolta.detectado) {
    respostaProcessada = formatarIdaVolta(respostaProcessada);
  }
  
  return respostaProcessada;
}

function formatarMultiplasOpcoes(texto) {
  // Garantir que op√ß√µes estejam bem separadas
  return texto.replace(/OP√á√ÉO (\d+)/g, '\nüî∏ **OP√á√ÉO $1**');
}

function formatarIdaVolta(texto) {
  // Garantir separa√ß√£o clara entre ida e volta
  return texto.replace(/(VOO DE VOLTA|VOLTA)/gi, '\n‚úàÔ∏è **$1**');
}

// ================================================================================
// üí∞ SISTEMA DE CUSTOS CORRIGIDO (DEBUG PERMANENTE)
// ================================================================================

async function registrarCustos(prompt, resposta, modelo, destino) {
  try {
    console.log('\nüß™ === DEBUG CUSTOS PERMANENTE v7.1 ===');
    
    // Calcular tokens (aproxima√ß√£o)
    const tokensInput = Math.ceil(prompt.length / 4);
    const tokensOutput = Math.ceil(resposta.length / 4);
    const tokensTotal = tokensInput + tokensOutput;
    
    console.log(`üì• Input: ${tokensInput} tokens`);
    console.log(`üì§ Output: ${tokensOutput} tokens`);
    console.log(`üìä Total: ${tokensTotal} tokens`);
    console.log(`ü§ñ Modelo: ${modelo}`);
    
    // Pre√ßos corretos por modelo (por 1K tokens)
    const precos = {
      'gpt-4o-mini': {
        input: 0.00015,
        output: 0.0006
      },
      'gpt-4o': {
        input: 0.0025,
        output: 0.01
      },
      'claude-3-5-sonnet-20240620': {
        input: 0.003,
        output: 0.015
      }
    };
    
    const preco = precos[modelo] || precos['gpt-4o-mini'];
    
    // C√°lculo CORRETO
    const custoInputUSD = (tokensInput / 1000) * preco.input;
    const custoOutputUSD = (tokensOutput / 1000) * preco.output;
    const custoTotalUSD = custoInputUSD + custoOutputUSD;
    
    // Convers√£o para BRL (taxa atual aproximada)
    const taxaBRL = 5.2;
    const custoTotalBRL = custoTotalUSD * taxaBRL;
    
    console.log(`üíµ Custo USD: ${custoTotalUSD.toFixed(6)}`);
    console.log(`üí∏ Custo BRL: R${custoTotalBRL.toFixed(6)}`);
    
    // Registrar na planilha Google Sheets
    await salvarCustoNaPlanilha({
      timestamp: new Date().toISOString(),
      destino: destino || 'N/A',
      modelo: modelo,
      tokensInput: tokensInput,
      tokensOutput: tokensOutput,
      tokensTotal: tokensTotal,
      custoUSD: custoTotalUSD.toFixed(6),
      custoBRL: custoTotalBRL.toFixed(6),
      promptSize: prompt.length,
      responseSize: resposta.length
    });
    
    console.log('‚úÖ Custos registrados na planilha');
    console.log('üß™ === FIM DEBUG CUSTOS ===\n');
    
  } catch (error) {
    console.error('‚ùå Erro ao registrar custos:', error);
    // N√£o interromper o fluxo principal por erro de log
  }
}

async function salvarCustoNaPlanilha(dados) {
  try {
    // URL do Google Apps Script para registrar custos
    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxqOxRJNJm_X4lmD1-4v4OZYRt7E5xh0mYaX1kgRv-fGfFTU4YZM7UWQm8YrWl1B4VQ/exec';
    
    const response = await fetch(SCRIPT_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        action: 'registrarCusto',
        dados: dados
      })
    });
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    
    const resultado = await response.json();
    console.log('üìä Resposta da planilha:', resultado);
    
  } catch (error) {
    console.error('‚ùå Erro ao salvar na planilha:', error);
    // N√£o interromper o fluxo principal por erro de log
  }
}

// ================================================================================
// üîß UTILIT√ÅRIOS DE VALIDA√á√ÉO E FORMATA√á√ÉO
// ================================================================================

function validarDados(formData) {
  const erros = [];
  
  if (!formData.destino || formData.destino.trim() === '') {
    erros.push('Destino √© obrigat√≥rio');
  }
  
  if (!formData.tipos || formData.tipos.length === 0) {
    erros.push('Selecione pelo menos um tipo de or√ßamento');
  }
  
  if (!formData.observacoes && !formData.textoColado && !formData.prompt) {
    erros.push('Forne√ßa observa√ß√µes, cole informa√ß√µes da viagem ou adicione um prompt');
  }
  
  return {
    valido: erros.length === 0,
    erros
  };
}

function formatarTimestamp() {
  return new Date().toLocaleString('pt-BR', {
    timeZone: 'America/Sao_Paulo',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
}

function sanitizarTexto(texto) {
  if (!texto) return '';
  
  return texto
    .trim()
    .replace(/[\r\n]+/g, '\n') // Normalizar quebras de linha
    .replace(/\s+/g, ' ') // Normalizar espa√ßos
    .substring(0, 10000); // Limitar tamanho para evitar tokens excessivos
}

// ================================================================================
// üîç SISTEMA DE DETEC√á√ÉO AVAN√áADA
// ================================================================================

function detectarPadroesCruzeiro(texto) {
  const padroes = [
    /\b(cruzeiro|cruise|navio)\b/gi,
    /\b(msc|costa|royal caribbean|carnival)\b/gi,
    /\b(cabine|suite|balc√£o)\b/gi,
    /\b(embarque|porto|terminal)\b/gi
  ];
  
  const deteccoes = padroes.map(p => p.test(texto));
  const confianca = deteccoes.filter(d => d).length / padroes.length;
  
  return {
    detectado: confianca >= 0.5,
    confianca: confianca
  };
}

function detectarPadroesHotel(texto) {
  const padroes = [
    /\b(hotel|resort|pousada|hostel)\b/gi,
    /\b(di√°ria|di√°rias|estadia|hospedagem)\b/gi,
    /\b(quarto|suite|apartamento)\b/gi,
    /\b(caf√© da manh√£|pens√£o completa|all inclusive)\b/gi
  ];
  
  const deteccoes = padroes.map(p => p.test(texto));
  const confianca = deteccoes.filter(d => d).length / padroes.length;
  
  return {
    detectado: confianca >= 0.5,
    confianca: confianca
  };
}

function detectarPadroesAereo(texto) {
  const padroes = [
    /\b(voo|passagem|a√©reo|flight)\b/gi,
    /\b(ida|volta|retorno)\b/gi,
    /\b(aeroporto|terminal)\b/gi,
    /\b(decolagem|pouso|embarque)\b/gi,
    /\d{2}:\d{2}/g // Hor√°rios
  ];
  
  const deteccoes = padroes.map(p => p.test(texto));
  const confianca = deteccoes.filter(d => d).length / padroes.length;
  
  return {
    detectado: confianca >= 0.4,
    confianca: confianca
  };
}

// ================================================================================
// üìä SISTEMA DE M√âTRICAS E LOGS DETALHADOS
// ================================================================================

function logMetricasDetalhadas(tipo, dados, analise, modelo) {
  console.log(`\nüìä === M√âTRICAS DETALHADAS - ${tipo.toUpperCase()} ===`);
  console.log(`‚è∞ Timestamp: ${formatarTimestamp()}`);
  console.log(`üéØ Destino: ${dados.destino || 'N/A'}`);
  console.log(`üè∑Ô∏è Tipos: ${dados.tipos?.join(', ') || 'N/A'}`);
  console.log(`üì± Tem imagem: ${dados.temImagem ? 'Sim' : 'N√£o'}`);
  console.log(`üìù Tamanho texto: ${analise.tamanhoTexto} chars`);
  console.log(`ü§ñ Modelo selecionado: ${modelo}`);
  console.log(`üîç Complexidade: ${analise.complexidade}`);
  console.log(`üé≠ Tipo espec√≠fico: ${analise.tipoEspecifico.principal}`);
  console.log(`üî¢ M√∫ltiplas op√ß√µes: ${analise.multiplasOpcoes.detectado ? 'Sim' : 'N√£o'}`);
  console.log(`‚ÜîÔ∏è Ida e volta: ${analise.idaVolta.detectado ? 'Sim' : 'N√£o'}`);
  console.log(`üìä === FIM M√âTRICAS ===\n`);
}

function logErroDetalhado(error, contexto) {
  console.error(`\n‚ùå === ERRO DETALHADO ===`);
  console.error(`‚è∞ Timestamp: ${formatarTimestamp()}`);
  console.error(`üìç Contexto: ${contexto}`);
  console.error(`üî¥ Mensagem: ${error.message}`);
  console.error(`üìö Stack: ${error.stack?.split('\n').slice(0, 3).join('\n')}`);
  console.error(`‚ùå === FIM ERRO ===\n`);
}

// ================================================================================
// üß™ SISTEMA DE TESTES E VALIDA√á√ÉO
// ================================================================================

function validarConfiguracao() {
  const config = {
    openai: !!process.env.OPENAI_API_KEY,
    anthropic: !!process.env.ANTHROPIC_API_KEY,
    timestamp: new Date().toISOString()
  };
  
  console.log('üß™ Valida√ß√£o de configura√ß√£o:', config);
  
  if (!config.openai && !config.anthropic) {
    throw new Error('Nenhuma API key configurada (OpenAI ou Anthropic)');
  }
  
  return config;
}

function testarModelos() {
  const modelosDisponiveis = [];
  
  if (process.env.OPENAI_API_KEY) {
    modelosDisponiveis.push('gpt-4o', 'gpt-4o-mini');
  }
  
  if (process.env.ANTHROPIC_API_KEY) {
    modelosDisponiveis.push('claude-3-5-sonnet-20240620');
  }
  
  console.log('ü§ñ Modelos dispon√≠veis:', modelosDisponiveis);
  return modelosDisponiveis;
}

// ================================================================================
// üöÄ INICIALIZA√á√ÉO DO SISTEMA
// ================================================================================

// Validar configura√ß√£o na inicializa√ß√£o
try {
  validarConfiguracao();
  testarModelos();
  console.log("‚úÖ CVC ITAQUA API v7.1 carregada com sucesso!");
  console.log("üîß Compatibilidade: v6.x + v7.0+ | Corre√ß√£o: tipos/tipo resolvida");
  console.log("üéØ Funcionalidades: Or√ßamentos, Rankings, Dicas, An√°lises");
  console.log("ü§ñ IA: OpenAI + Claude | Templates: 4 tipos otimizados");
  console.log("üí∞ Custos: Registro autom√°tico na planilha");
  console.log("üêõ Debug: Logs detalhados permanentes");
} catch (error) {
  console.error("‚ùå Erro na inicializa√ß√£o:", error.message);
}

// ================================================================================
// üìã EXPORTS E UTILIT√ÅRIOS FINAIS
// ================================================================================

// Fun√ß√£o de sa√∫de do sistema
export function healthCheck() {
  return {
    status: 'healthy',
    version: '7.1',
    timestamp: new Date().toISOString(),
    features: {
      orcamentos: true,
      rankings: true,
      dicas: true,
      analises: true,
      multiplos_formatos: true,
      templates_otimizados: true,
      dual_ai: true,
      registro_custos: true
    },
    apis: {
      openai: !!process.env.OPENAI_API_KEY,
      anthropic: !!process.env.ANTHROPIC_API_KEY
    }
  };
}

// Fun√ß√£o de debug para testes
export function debugInfo(req) {
  return {
    method: req.method,
    headers: Object.keys(req.headers),
    bodyKeys: req.body ? Object.keys(req.body) : null,
    bodySize: req.body ? JSON.stringify(req.body).length : 0,
    timestamp: new Date().toISOString()
  };
}
