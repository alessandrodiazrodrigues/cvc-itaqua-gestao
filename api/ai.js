// üöÄ api/ai.js - MODULAR FUNCIONAL CORRETO v7.7
// RESOLVIDO: Importa√ß√£o din√¢mica + Fallbacks + Compatibilidade total

console.log("üöÄ CVC ITAQUA API v7.7 - MODULAR FUNCIONAL");

export default async function handler(req, res) {
  const inicio = Date.now();
  
  console.log("üìä M√©todo:", req.method, "| Timestamp:", new Date().toISOString());

  // ================================================================================
  // üîß CORS E VALIDA√á√ÉO
  // ================================================================================
  
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  res.setHeader('X-Powered-By', 'CVC-Itaqua-AI-v7.7');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      error: 'M√©todo n√£o permitido',
      versao: '7.7-modular'
    });
  }

  try {
    // ================================================================================
    // üîß NORMALIZA√á√ÉO DE DADOS
    // ================================================================================
    
    let formData, tipo;
    
    if (req.body?.formData && req.body?.tipo) {
      formData = req.body.formData;
      tipo = req.body.tipo;
    } else if (req.body?.tipos || req.body?.observacoes) {
      formData = req.body;
      tipo = 'orcamento';
    } else {
      throw new Error("Formato de dados inv√°lido");
    }

    // Normalizar tipos
    if (!formData.tipos) {
      formData.tipos = formData.tipo ? [formData.tipo] : ['A√©reo Nacional'];
    }
    if (!Array.isArray(formData.tipos)) {
      formData.tipos = [formData.tipos];
    }

    console.log("üéØ Dados normalizados:", { 
      tipo, 
      tipos: formData.tipos, 
      destino: formData.destino,
      hasObservacoes: !!formData.observacoes,
      hasTextoColado: !!formData.textoColado
    });

    // ================================================================================
    // üéØ CARREGAR M√ìDULOS DINAMICAMENTE (RESOLVENDO INCOMPATIBILIDADE)
    // ================================================================================
    
    let moduloTemplates, moduloAnalysis, moduloProcessing;
    
    try {
      // Importa√ß√£o din√¢mica para resolver ES6/CommonJS
      moduloTemplates = await import('./modules/templates.js');
      moduloAnalysis = await import('./modules/analysis.js');
      moduloProcessing = await import('./modules/processing.js');
      
      console.log("‚úÖ M√≥dulos carregados com sucesso");
    } catch (errorImport) {
      console.log("‚ö†Ô∏è Erro ao carregar m√≥dulos:", errorImport.message);
      console.log("üîÑ Usando implementa√ß√£o fallback integrada");
      
      // Se m√≥dulos falharem, usar implementa√ß√£o integrada
      return await processarComFallbackIntegrado(formData, tipo, res, inicio);
    }

    // ================================================================================
    // üéØ PROCESSAMENTO USANDO M√ìDULOS
    // ================================================================================
    
    let resultado;
    
    switch (tipo) {
      case 'orcamento':
        resultado = await processarOrcamentoModular(formData, moduloTemplates, moduloAnalysis, moduloProcessing);
        break;
      case 'ranking':
        resultado = await processarRankingModular(formData, moduloTemplates);
        break;
      case 'dicas':
        resultado = await processarDicasModular(formData, moduloTemplates);
        break;
      default:
        throw new Error(`Tipo n√£o suportado: ${tipo}`);
    }

    // ================================================================================
    // üìä RESPOSTA FINAL
    // ================================================================================
    
    const tempoTotal = Date.now() - inicio;
    
    console.log("‚úÖ Processamento modular conclu√≠do:", tempoTotal + "ms");
    
    return res.status(200).json({
      success: true,
      result: resultado.conteudo,
      versao: '7.7-modular',
      timestamp: new Date().toISOString(),
      debug: {
        tipoOperacao: tipo,
        tiposOrcamento: formData.tipos,
        tempoProcessamento: `${tempoTotal}ms`,
        templateUsado: resultado.templateUsado,
        modeloUsado: resultado.modeloUsado,
        modulosCarregados: true,
        detalhesCompletos: resultado.detalhesProcessamento || {
          status: 'Detalhes n√£o dispon√≠veis para este tipo de opera√ß√£o'
        }
      }
    });

  } catch (error) {
    const tempoTotal = Date.now() - inicio;
    
    console.error("‚ùå Erro na API:", error);
    
    return res.status(500).json({
      success: false,
      error: error.message,
      versao: '7.7-modular',
      timestamp: new Date().toISOString(),
      debug: {
        tempoProcessamento: `${tempoTotal}ms`,
        errorStack: error.stack?.split('\n').slice(0, 3)
      }
    });
  }
}

// ================================================================================
// üéØ PROCESSAMENTO MODULAR - USA OS M√ìDULOS CORRETOS
// ================================================================================

async function processarOrcamentoModular(formData, moduloTemplates, moduloAnalysis, moduloProcessing) {
  console.log("üéØ Processamento modular de or√ßamento...");
  
  try {
    const textoCompleto = `${formData.observacoes || ''} ${formData.textoColado || ''} ${formData.prompt || ''}`;
    
    // ETAPA 1: An√°lise usando m√≥dulo analysis.js
    let analise;
    if (moduloAnalysis && moduloAnalysis.analisarTextoCompleto) {
      analise = moduloAnalysis.analisarTextoCompleto(formData);
      console.log("‚úÖ An√°lise modular aplicada");
    } else {
      // Fallback an√°lise simples
      analise = analisarTextoSimples(textoCompleto);
      console.log("‚ö†Ô∏è An√°lise fallback aplicada");
    }
    
    // ETAPA 2: Aplicar template usando m√≥dulo templates.js
    let templateResult;
    let templateUsadoReal = 'desconhecido';
    
    if (moduloTemplates && moduloTemplates.aplicarTemplateCompleto) {
      templateResult = moduloTemplates.aplicarTemplateCompleto(formData, analise);
      templateUsadoReal = 'templates.js-aplicarTemplateCompleto';
      console.log("‚úÖ Template modular aplicado via aplicarTemplateCompleto()");
    } else if (moduloTemplates && moduloTemplates.default && moduloTemplates.default.aplicarTemplateCompleto) {
      templateResult = moduloTemplates.default.aplicarTemplateCompleto(formData, analise);
      templateUsadoReal = 'templates.js-default-aplicarTemplateCompleto';
      console.log("‚úÖ Template modular (default export) aplicado via default.aplicarTemplateCompleto()");
    } else {
      console.log("‚ö†Ô∏è Template modular n√£o encontrado, usando fallback integrado");
      console.log("üìã M√≥dulos dispon√≠veis:", moduloTemplates ? Object.keys(moduloTemplates) : 'nenhum');
      templateResult = gerarTemplateManualIntegrado(formData, textoCompleto, analise);
      templateUsadoReal = 'fallback-integrado-manual';
    }
    
    // ETAPA 3: Processar com IA ou usar template direto
    let conteudoFinal;
    if (typeof templateResult === 'string' && templateResult.startsWith('*')) {
      // Se templateResult j√° √© um or√ßamento formatado, usar diretamente
      conteudoFinal = templateResult;
      console.log("‚úÖ Template direto usado");
    } else {
      // Se templateResult √© um prompt, chamar IA
      console.log("ü§ñ Chamando IA com template como prompt...");
      
      if (process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY.startsWith('sk-')) {
        try {
          const respostaIA = await chamarOpenAI(templateResult.toString());
          conteudoFinal = respostaIA.content;
          console.log("‚úÖ IA processou o template");
        } catch (errorIA) {
          console.log("‚ö†Ô∏è IA falhou, usando template direto:", errorIA.message);
          conteudoFinal = gerarTemplateManualIntegrado(formData, textoCompleto, analise);
        }
      } else {
        console.log("üí≠ OpenAI n√£o configurada, usando template direto");
        conteudoFinal = gerarTemplateManualIntegrado(formData, textoCompleto, analise);
      }
    }
    
    // ETAPA 4: Processamento final usando m√≥dulo processing.js
    if (moduloProcessing && moduloProcessing.processarRespostaCompleta) {
      conteudoFinal = moduloProcessing.processarRespostaCompleta(conteudoFinal, analise);
      console.log("‚úÖ Processamento modular aplicado");
    } else if (moduloProcessing && moduloProcessing.default && moduloProcessing.default.processarRespostaCompleta) {
      conteudoFinal = moduloProcessing.default.processarRespostaCompleta(conteudoFinal, analise);
      console.log("‚úÖ Processamento modular (default export) aplicado");
    } else {
      console.log("‚ö†Ô∏è Processamento modular n√£o encontrado, usando formata√ß√£o b√°sica");
      conteudoFinal = aplicarFormatacaoBasica(conteudoFinal);
    }
    
    return {
      conteudo: conteudoFinal,
      templateUsado: templateUsadoReal,
      modeloUsado: 'template-ia-hibrido',
      detalhesProcessamento: {
        moduloTemplatesCarregado: !!moduloTemplates,
        funcaoTemplateUsada: templateUsadoReal,
        analiseModular: moduloAnalysis ? 'SIM' : 'N√ÉO',
        processamentoModular: moduloProcessing ? 'SIM' : 'N√ÉO',
        iaUtilizada: conteudoFinal !== templateResult ? 'SIM' : 'N√ÉO'
      }
    };
    
  } catch (error) {
    console.error("‚ùå Erro no processamento modular:", error);
    
    // Fallback de emerg√™ncia
    const textoCompleto = `${formData.observacoes || ''} ${formData.textoColado || ''} ${formData.prompt || ''}`;
    const conteudoEmergencia = gerarTemplateManualIntegrado(formData, textoCompleto, null);
    
    return {
      conteudo: conteudoEmergencia,
      templateUsado: 'fallback-emergencia',
      modeloUsado: 'template-manual'
    };
  }
}

// ================================================================================
// ü§ñ CLIENTE OPENAI
// ================================================================================

async function chamarOpenAI(prompt) {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OpenAI API key n√£o configurada');
  }

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 1500,
      temperature: 0.3
    })
  });

  if (!response.ok) {
    const errorData = await response.text();
    throw new Error(`OpenAI Error ${response.status}: ${errorData.substring(0, 200)}`);
  }

  const data = await response.json();
  
  if (!data.choices?.[0]?.message?.content) {
    throw new Error("Resposta inv√°lida da OpenAI");
  }

  return {
    content: data.choices[0].message.content,
    usage: data.usage || {}
  };
}

// ================================================================================
// üîÑ FALLBACK INTEGRADO (SE M√ìDULOS FALHAREM)
// ================================================================================

async function processarComFallbackIntegrado(formData, tipo, res, inicio) {
  console.log("üîÑ Processando com fallback integrado...");
  
  try {
    const textoCompleto = `${formData.observacoes || ''} ${formData.textoColado || ''} ${formData.prompt || ''}`;
    const analise = analisarTextoSimples(textoCompleto);
    
    let resultado;
    switch (tipo) {
      case 'orcamento':
        resultado = {
          conteudo: gerarTemplateManualIntegrado(formData, textoCompleto, analise),
          templateUsado: 'fallback-integrado',
          modeloUsado: 'template-manual'
        };
        break;
      case 'ranking':
        resultado = {
          conteudo: gerarRankingPadrao(formData.destino),
          templateUsado: 'ranking-padrao',
          modeloUsado: 'template'
        };
        break;
      case 'dicas':
        resultado = {
          conteudo: gerarDicasPadrao(formData.destino),
          templateUsado: 'dicas-padrao',
          modeloUsado: 'template'
        };
        break;
      default:
        throw new Error(`Tipo n√£o suportado: ${tipo}`);
    }
    
    const tempoTotal = Date.now() - inicio;
    
    return res.status(200).json({
      success: true,
      result: resultado.conteudo,
      versao: '7.7-fallback',
      timestamp: new Date().toISOString(),
      debug: {
        tipoOperacao: tipo,
        tiposOrcamento: formData.tipos,
        tempoProcessamento: `${tempoTotal}ms`,
        templateUsado: resultado.templateUsado,
        modeloUsado: resultado.modeloUsado,
        modulosCarregados: false,
        usandoFallback: true
      }
    });
    
  } catch (error) {
    const tempoTotal = Date.now() - inicio;
    
    return res.status(500).json({
      success: false,
      error: error.message,
      versao: '7.7-fallback',
      timestamp: new Date().toISOString(),
      debug: {
        tempoProcessamento: `${tempoTotal}ms`,
        usandoFallback: true,
        errorStack: error.stack?.split('\n').slice(0, 3)
      }
    });
  }
}

// ================================================================================
// üîç AN√ÅLISE SIMPLES (FALLBACK)
// ================================================================================

function analisarTextoSimples(texto) {
  const textoLower = texto.toLowerCase();
  
  // DETEC√á√ÉO MELHORADA DE CRUZEIRO
  const ehCruzeiro = textoLower.includes('cruzeiro') || 
                    textoLower.includes('navio') ||
                    textoLower.includes('msc') ||
                    textoLower.includes('costa') ||
                    textoLower.includes('embarque: santos') ||
                    textoLower.includes('desembarque: santos') ||
                    textoLower.includes('sinfonia') ||
                    textoLower.includes('cabine') ||
                    (textoLower.includes('embarque') && textoLower.includes('santos'));
  
  console.log("üîç An√°lise de cruzeiro:", {
    texto: texto.substring(0, 100),
    ehCruzeiro,
    temMSC: textoLower.includes('msc'),
    temSantos: textoLower.includes('santos'),
    temEmbarque: textoLower.includes('embarque')
  });
  
  return {
    ehCruzeiro,
    ehMultiplasOpcoes: textoLower.includes('op√ß√£o 1') || textoLower.includes('op√ß√£o 2'),
    ehSomenteIda: textoLower.includes('somente ida') || (!textoLower.includes('volta') && !textoLower.includes('retorno')),
    temConexao: textoLower.includes('conex√£o') || textoLower.includes('escala'),
    ehInternacional: textoLower.includes('miami') || textoLower.includes('europa') || textoLower.includes('internacional'),
    ehPacote: textoLower.includes('hotel') || textoLower.includes('pacote') || textoLower.includes('hospedagem'),
    tipoDetectado: detectarTipoPrincipal(textoLower, ehCruzeiro),
    confiancaDeteccao: 0.8
  };
}

function detectarTipoPrincipal(textoLower, ehCruzeiro = false) {
  console.log("üéØ Detectando tipo principal:", {
    ehCruzeiro,
    temMSC: textoLower.includes('msc'),
    temCruzeiro: textoLower.includes('cruzeiro'),
    temSantos: textoLower.includes('santos')
  });
  
  if (ehCruzeiro || textoLower.includes('cruzeiro') || textoLower.includes('msc')) {
    console.log("‚úÖ TIPO DETECTADO: CRUZEIRO");
    return 'cruzeiro';
  }
  if (textoLower.includes('op√ß√£o 1')) {
    console.log("‚úÖ TIPO DETECTADO: M√öLTIPLAS OP√á√ïES");
    return 'multiplas_opcoes';
  }
  if (textoLower.includes('hotel')) {
    console.log("‚úÖ TIPO DETECTADO: PACOTE");
    return 'pacote_completo';
  }
  
  console.log("‚úÖ TIPO DETECTADO: A√âREO (padr√£o)");
  return 'aereo_ida_volta';
}

// ================================================================================
// üìã TEMPLATE MANUAL INTEGRADO (FALLBACK PRINCIPAL)
// ================================================================================

function gerarTemplateManualIntegrado(formData, textoCompleto, analise) {
  console.log("üìã Gerando template manual integrado...");
  console.log("üîç An√°lise recebida:", analise);
  
  // Extrair dados do texto
  const dados = extrairDadosCompletos(textoCompleto, formData);
  console.log("üìä Dados extra√≠dos:", dados);
  
  // CORRE√á√ÉO: Aplicar template baseado na an√°lise E no texto
  const textoLower = textoCompleto.toLowerCase();
  
  if (analise?.ehCruzeiro || textoLower.includes('cruzeiro') || textoLower.includes('msc') || textoLower.includes('sinfonia')) {
    console.log("üö¢ APLICANDO TEMPLATE DE CRUZEIRO");
    return gerarTemplateCruzeiro(dados);
  }
  
  if (analise?.ehMultiplasOpcoes || textoLower.includes('op√ß√£o')) {
    console.log("üî¢ APLICANDO TEMPLATE DE M√öLTIPLAS OP√á√ïES");
    return gerarTemplateMultiplasOpcoes(dados);
  }
  
  if (analise?.ehPacote || textoLower.includes('hotel')) {
    console.log("üè® APLICANDO TEMPLATE DE PACOTE");
    return gerarTemplatePacote(dados);
  }
  
  // Template a√©reo padr√£o
  console.log("‚úàÔ∏è APLICANDO TEMPLATE A√âREO (padr√£o)");
  return gerarTemplateAereo(dados);
}

function gerarTemplateAereo(dados) {
  return `*${dados.companhia} - ${dados.origem} ‚úà ${dados.destino}*
${dados.dataIda} - ${dados.aeroportoOrigem} ${dados.horaIda} / ${dados.aeroportoDestino} ${dados.horaChegadaIda} (${dados.tipoVooIda})
--
${dados.dataVolta} - ${dados.aeroportoDestino} ${dados.horaVolta} / ${dados.aeroportoOrigem} ${dados.horaChegadaVolta} (${dados.tipoVooVolta})

üí∞ ${dados.valor} para ${dados.passageiros}
‚úÖ ${dados.bagagem}
üè∑Ô∏è ${dados.reembolso}`;
}

function gerarTemplateCruzeiro(dados) {
  console.log("üö¢ Gerando template de cruzeiro com dados:", dados);
  
  return `üö¢ *Cruzeiro ${dados.navio}* ‚Äì ${dados.duracao} noites
üë• ${dados.passageiros}
üìÖ Embarque: ${dados.dataEmbarque} (${dados.porto})
üåä Roteiro incr√≠vel pelo litoral brasileiro!

üí∞ Op√ß√µes de Cabines:
**CABINE INTERNA** - ${dados.valor}
**CABINE EXTERNA** - ${dados.valorExterna}
**CABINE VARANDA** - ${dados.valorVaranda}

‚úÖ Inclui: hospedagem a bordo, pens√£o completa
üö´ N√£o inclui: taxas portu√°rias, bebidas, excurs√µes

üìã Documenta√ß√£o: RG original (m√°x. 10 anos) ou passaporte

üì≤ Me chama pra garantir a sua cabine! üå¥üõ≥Ô∏è`;
}

function gerarTemplateMultiplasOpcoes(dados) {
  return `*${dados.companhia} - ${dados.origem} ‚úà ${dados.destino}*
${dados.dataIda} - ${dados.aeroportoOrigem} ${dados.horaIda} / ${dados.aeroportoDestino} ${dados.horaChegadaIda} (${dados.tipoVooIda})
--
${dados.dataVolta} - ${dados.aeroportoDestino} ${dados.horaVolta} / ${dados.aeroportoOrigem} ${dados.horaChegadaVolta} (${dados.tipoVooVolta})

üí∞ **OP√á√ÉO 1** - ${dados.valor}
‚úÖ S√≥ mala de m√£o inclu√≠da
üí≥ 10x de R$ ${(parseFloat(dados.valor.replace(/[^\d,]/g, '').replace(',', '.')) / 10).toFixed(2).replace('.', ',')} s/ juros no cart√£o

üí∞ **OP√á√ÉO 2** - ${dados.valor2}
‚úÖ Mala de m√£o + bagagem despachada
‚úÖ Cancelamento/altera√ß√£o com multas
‚úÖ Reembols√°vel conforme regras do bilhete
üí≥ 10x de R$ ${(parseFloat(dados.valor2.replace(/[^\d,]/g, '').replace(',', '.')) / 10).toFixed(2).replace('.', ',')} s/ juros no cart√£o

Valores sujeitos a confirma√ß√£o e disponibilidade`;
}

function gerarTemplatePacote(dados) {
  return `*Pacote ${dados.destino}*
Embarque: ${dados.dataIda}
Pacote para ${dados.passageiros}

*O Pacote Inclui:*
- Passagem A√©rea ida e volta para ${dados.destino}
- Taxas de Embarque
- Traslado Aeroporto / Hotel / Aeroporto
- ${dados.noites} noites de hospedagem no hotel escolhido

‚úàÔ∏è *Voos ${dados.companhia}:*
${dados.dataIda} - ${dados.origem} ${dados.horaIda} / ${dados.destino} ${dados.horaChegadaIda} (${dados.tipoVooIda})
--
${dados.dataVolta} - ${dados.destino} ${dados.horaVolta} / ${dados.origem} ${dados.horaChegadaVolta} (${dados.tipoVooVolta})

**OP√á√ÉO 1** - Hotel Boa Viagem
üõèÔ∏è 1 Standard com caf√© da manh√£
üí∞ ${dados.valor} para ${dados.passageiros}

**OP√á√ÉO 2** - Resort Coral Plaza
üõèÔ∏è 1 Superior com meia pens√£o
üí∞ ${dados.valor2} para ${dados.passageiros}

Valores sujeitos a confirma√ß√£o e disponibilidade`;
}

// ================================================================================
// üîç EXTRA√á√ÉO COMPLETA DE DADOS
// ================================================================================

function extrairDadosCompletos(texto, formData) {
  console.log("üîç Extraindo dados de:", texto.substring(0, 200));
  
  // Detec√ß√£o espec√≠fica para cruzeiro
  const ehCruzeiro = texto.toLowerCase().includes('msc') || 
                    texto.toLowerCase().includes('cruzeiro') ||
                    texto.toLowerCase().includes('sinfonia');
  
  if (ehCruzeiro) {
    console.log("üö¢ Extraindo dados de CRUZEIRO");
    
    // Extrair dados espec√≠ficos do cruzeiro
    const navio = extrairNavio(texto);
    const duracao = extrairDuracao(texto);
    const valor = extrairValor(texto);
    const passageiros = formatarPassageiros(formData.adultos, formData.criancas);
    
    console.log("üìä Dados do cruzeiro:", { navio, duracao, valor, passageiros });
    
    return {
      // Dados de cruzeiro
      navio,
      duracao,
      valor,
      valorExterna: calcularValorExterna(valor),
      valorVaranda: calcularValorVaranda(valor),
      passageiros,
      dataEmbarque: extrairDataEmbarque(texto),
      porto: extrairPorto(texto),
      
      // Dados b√°sicos (fallback)
      companhia: 'MSC',
      origem: 'Santos',
      destino: 'Santos',
      bagagem: 'Hospedagem a bordo inclu√≠da',
      reembolso: 'Conforme regras da companhia',
      noites: duracao
    };
  }
  
  // Dados para outros tipos (a√©reo, etc.)
  return {
    // Dados b√°sicos
    companhia: extrairCompanhia(texto),
    origem: 'S√£o Paulo',
    destino: extrairDestino(texto) || formData.destino || 'Recife',
    
    // Aeroportos
    aeroportoOrigem: extrairAeroportoOrigem(texto),
    aeroportoDestino: extrairAeroportoDestino(texto),
    
    // Datas
    dataIda: extrairDataIda(texto),
    dataVolta: extrairDataVolta(texto),
    
    // Hor√°rios
    horaIda: extrairHoraIda(texto),
    horaChegadaIda: extrairHoraChegadaIda(texto),
    horaVolta: extrairHoraVolta(texto),
    horaChegadaVolta: extrairHoraChegadaVolta(texto),
    
    // Tipo de voo
    tipoVooIda: texto.toLowerCase().includes('direto') ? 'voo direto' : 'com conex√£o',
    tipoVooVolta: texto.toLowerCase().includes('direto') ? 'voo direto' : 'com conex√£o',
    
    // Valores
    valor: extrairValor(texto),
    valor2: extrairValor2(texto),
    valorExterna: calcularValorExterna(extrairValor(texto)),
    valorVaranda: calcularValorVaranda(extrairValor(texto)),
    
    // Passageiros
    passageiros: formatarPassageiros(formData.adultos, formData.criancas),
    
    // Outros
    bagagem: 'S√≥ mala de m√£o inclu√≠da',
    reembolso: 'N√£o reembols√°vel',
    
    // Cruzeiro (fallback)
    navio: 'MSC Sinfonia',
    duracao: '3',
    dataEmbarque: extrairDataIda(texto) || '25/11',
    porto: 'Santos',
    
    // Pacote
    noites: '7'
  };
}

// ================================================================================
// üîç FUN√á√ïES DE EXTRA√á√ÉO ESPEC√çFICAS PARA CRUZEIRO
// ================================================================================

function extrairNavio(texto) {
  if (texto.toLowerCase().includes('msc sinfonia')) return 'MSC Sinfonia';
  if (texto.toLowerCase().includes('sinfonia')) return 'MSC Sinfonia';
  if (texto.toLowerCase().includes('costa diadema')) return 'Costa Diadema';
  if (texto.toLowerCase().includes('msc')) return 'MSC Sinfonia';
  return 'MSC Sinfonia';
}

function extrairDuracao(texto) {
  const match = texto.match(/(\d+)\s*noites?/i);
  if (match) return match[1];
  
  const matchDias = texto.match(/(\d+)\s*dias?/i);
  if (matchDias) return (parseInt(matchDias[1]) - 1).toString();
  
  return '3'; // Padr√£o do exemplo
}

function extrairPorto(texto) {
  if (texto.toLowerCase().includes('santos')) return 'Santos';
  if (texto.toLowerCase().includes('rio de janeiro')) return 'Rio de Janeiro';
  return 'Santos';
}

function extrairDataEmbarque(texto) {
  // Procurar por data no formato 25/11/2025 ou 25/11
  const matchCompleta = texto.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
  if (matchCompleta) {
    return `${matchCompleta[1].padStart(2, '0')}/${matchCompleta[2].padStart(2, '0')}`;
  }
  
  const matchSimples = texto.match(/(\d{1,2})\/(\d{1,2})/);
  if (matchSimples) {
    return `${matchSimples[1].padStart(2, '0')}/${matchSimples[2].padStart(2, '0')}`;
  }
  
  return '25/11';
}

// ================================================================================
// üîß FUN√á√ïES DE EXTRA√á√ÉO ORIGINAIS (MANTIDAS)
// ================================================================================

function extrairCompanhia(texto) {
  const companhias = {
    'latam': 'Latam', 'gol': 'Gol', 'azul': 'Azul', 'avianca': 'Avianca'
  };
  const textoLower = texto.toLowerCase();
  for (const [key, value] of Object.entries(companhias)) {
    if (textoLower.includes(key)) return value;
  }
  return 'Latam';
}

function extrairDestino(texto) {
  const cidades = {
    'recife': 'Recife', 'salvador': 'Salvador', 'fortaleza': 'Fortaleza',
    'natal': 'Natal', 'macei√≥': 'Macei√≥'
  };
  const textoLower = texto.toLowerCase();
  for (const [key, value] of Object.entries(cidades)) {
    if (textoLower.includes(key)) return value;
  }
  return 'Recife';
}

function extrairAeroportoOrigem(texto) {
  if (texto.includes('CGH') || texto.toLowerCase().includes('congonhas')) return 'Congonhas';
  if (texto.includes('GRU') || texto.toLowerCase().includes('guarulhos')) return 'Guarulhos';
  return 'Congonhas';
}

function extrairAeroportoDestino(texto) {
  if (texto.includes('REC')) return 'Recife';
  if (texto.includes('SSA')) return 'Salvador';
  if (texto.includes('FOR')) return 'Fortaleza';
  return 'Recife';
}

function extrairDataIda(texto) {
  const matchCompleta = texto.match(/(\d{1,2})\s+de\s+(\w+)/i);
  if (matchCompleta) {
    const dia = matchCompleta[1].padStart(2, '0');
    const mes = converterMes(matchCompleta[2]);
    return `${dia}/${mes}`;
  }
  const matchSimples = texto.match(/(\d{1,2})\/(\d{1,2})/);
  if (matchSimples) {
    return `${matchSimples[1].padStart(2, '0')}/${matchSimples[2].padStart(2, '0')}`;
  }
  return '14/08';
}

function extrairDataVolta(texto) {
  const matches = [...texto.matchAll(/(\d{1,2})\s+de\s+(\w+)/gi)];
  if (matches.length > 1) {
    const dia = matches[1][1].padStart(2, '0');
    const mes = converterMes(matches[1][2]);
    return `${dia}/${mes}`;
  }
  const matchesSimples = [...texto.matchAll(/(\d{1,2})\/(\d{1,2})/g)];
  if (matchesSimples.length > 1) {
    return `${matchesSimples[1][1].padStart(2, '0')}/${matchesSimples[1][2].padStart(2, '0')}`;
  }
  return '21/08';
}

function extrairHoraIda(texto) {
  const match = texto.match(/(\d{1,2}):(\d{2})/);
  return match ? `${match[1].padStart(2, '0')}:${match[2]}` : '07:55';
}

function extrairHoraChegadaIda(texto) {
  const matches = [...texto.matchAll(/(\d{1,2}):(\d{2})/g)];
  if (matches.length > 1) {
    return `${matches[1][1].padStart(2, '0')}:${matches[1][2]}`;
  }
  return '11:05';
}

function extrairHoraVolta(texto) {
  const matches = [...texto.matchAll(/(\d{1,2}):(\d{2})/g)];
  if (matches.length > 2) {
    return `${matches[2][1].padStart(2, '0')}:${matches[2][2]}`;
  }
  return '03:35';
}

function extrairHoraChegadaVolta(texto) {
  const matches = [...texto.matchAll(/(\d{1,2}):(\d{2})/g)];
  if (matches.length > 3) {
    return `${matches[3][1].padStart(2, '0')}:${matches[3][2]}`;
  }
  return '07:00';
}

function extrairValor(texto) {
  const match = texto.match(/R\$\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)/);
  return match ? `R$ ${match[1]}` : 'R$ 1.474,18';
}

function extrairValor2(texto) {
  const matches = [...texto.matchAll(/R\$\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)/g)];
  if (matches.length > 1) {
    return `R$ ${matches[1][1]}`;
  }
  return 'R$ 1.800,00';
}

function calcularValorExterna(valor) {
  if (!valor) return 'R$ 1.800,00';
  const num = parseFloat(valor.replace(/[^\d,]/g, '').replace(',', '.'));
  return `R$ ${(num * 1.3).toFixed(2).replace('.', ',')}`;
}

function calcularValorVaranda(valor) {
  if (!valor) return 'R$ 2.200,00';
  const num = parseFloat(valor.replace(/[^\d,]/g, '').replace(',', '.'));
  return `R$ ${(num * 1.6).toFixed(2).replace('.', ',')}`;
}

function formatarPassageiros(adultos, criancas) {
  const numAdultos = parseInt(adultos) || 2;
  let resultado = numAdultos === 1 ? '01 adulto' : `${numAdultos.toString().padStart(2, '0')} adultos`;
  
  if (criancas && parseInt(criancas) > 0) {
    const numCriancas = parseInt(criancas);
    resultado += ` + ${numCriancas.toString().padStart(2, '0')} ${numCriancas === 1 ? 'crian√ßa' : 'crian√ßas'}`;
  }
  
  return resultado;
}

function converterMes(mes) {
  const meses = {
    'janeiro': '01', 'fevereiro': '02', 'mar√ßo': '03', 'abril': '04',
    'maio': '05', 'junho': '06', 'julho': '07', 'agosto': '08',
    'setembro': '09', 'outubro': '10', 'novembro': '11', 'dezembro': '12'
  };
  return meses[mes.toLowerCase()] || '08';
}

// ================================================================================
// üé® FORMATA√á√ÉO B√ÅSICA
// ================================================================================

function aplicarFormatacaoBasica(conteudo) {
  let formatado = conteudo;
  
  // Garantir formato correto de hor√°rios
  formatado = formatado.replace(/(\d{1,2})\s*:\s*(\d{2})/g, '$1:$2');
  
  // Garantir formato correto de datas
  formatado = formatado.replace(/(\d{1,2})\/(\d{1,2})/g, (match, dia, mes) => {
    return `${dia.padStart(2, '0')}/${mes.padStart(2, '0')}`;
  });
  
  // Garantir formato correto de valores
  formatado = formatado.replace(/R\$\s*(\d)/g, 'R$ $1');
  
  // Limpar linhas excessivas
  formatado = formatado.replace(/\n\s*\n\s*\n/g, '\n\n');
  
  // Remover cabe√ßalhos t√©cnicos
  formatado = formatado.replace(/^OR√áAMENTO CVC.*?\n/gim, '');
  formatado = formatado.replace(/^DADOS DA VIAGEM.*?\n/gim, '');
  formatado = formatado.replace(/^TIPOS SELECIONADOS.*?\n/gim, '');
  
  return formatado.trim();
}

// ================================================================================
// üè® OUTROS PROCESSAMENTOS MODULARES
// ================================================================================

async function processarRankingModular(formData, moduloTemplates) {
  const destino = formData.destino || 'destino solicitado';
  
  // Tentar usar m√≥dulo templates se dispon√≠vel
  if (moduloTemplates && moduloTemplates.gerarRankingHoteis) {
    try {
      const resultado = moduloTemplates.gerarRankingHoteis(formData);
      return {
        conteudo: resultado,
        templateUsado: 'ranking-modular',
        modeloUsado: 'template'
      };
    } catch (error) {
      console.log("‚ö†Ô∏è Ranking modular falhou, usando fallback");
    }
  }
  
  // Fallback integrado
  return {
    conteudo: gerarRankingPadrao(destino),
    templateUsado: 'ranking-fallback',
    modeloUsado: 'template'
  };
}

async function processarDicasModular(formData, moduloTemplates) {
  const destino = formData.destino || 'destino solicitado';
  
  // Tentar usar m√≥dulo templates se dispon√≠vel
  if (moduloTemplates && moduloTemplates.gerarDicasDestino) {
    try {
      const resultado = moduloTemplates.gerarDicasDestino(formData);
      return {
        conteudo: resultado,
        templateUsado: 'dicas-modular',
        modeloUsado: 'template'
      };
    } catch (error) {
      console.log("‚ö†Ô∏è Dicas modulares falharam, usando fallback");
    }
  }
  
  // Fallback integrado
  return {
    conteudo: gerarDicasPadrao(destino),
    templateUsado: 'dicas-fallback',
    modeloUsado: 'template'
  };
}

// ================================================================================
// üìã TEMPLATES PADRAO (FALLBACK FINAL)
// ================================================================================

function gerarRankingPadrao(destino) {
  return `üè® RANKING DE HOT√âIS - ${destino.toUpperCase()}

üèÜ 1. Hotel Boa Viagem - ‚≠ê‚≠ê‚≠ê‚≠ê
üìç Boa Viagem, beira-mar
üí∞ R$ 200-350 por di√°ria
‚≠ê Localiza√ß√£o premium, caf√© da manh√£, piscina

üèÜ 2. Resort Coral Plaza - ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
üìç Zona tur√≠stica principal
üí∞ R$ 400-600 por di√°ria
‚≠ê All inclusive, spa, recrea√ß√£o infantil

üèÜ 3. Hotel Mar Azul - ‚≠ê‚≠ê‚≠ê
üìç Centro hist√≥rico
üí∞ R$ 150-250 por di√°ria
‚≠ê Custo-benef√≠cio, cultura, gastronomia

üèÜ 4. Pousada Tropical - ‚≠ê‚≠ê‚≠ê
üìç Regi√£o tranquila
üí∞ R$ 120-200 por di√°ria
‚≠ê Familiar, aconchegante, atendimento

üèÜ 5. Hotel Business - ‚≠ê‚≠ê‚≠ê‚≠ê
üìç Centro empresarial
üí∞ R$ 250-400 por di√°ria
‚≠ê Executivo, wi-fi, sala de reuni√µes`;
}

function gerarDicasPadrao(destino) {
  return `üí° DICAS DE VIAGEM - ${destino.toUpperCase()}

üå°Ô∏è MELHOR √âPOCA:
Dezembro a mar√ßo - ver√£o com sol garantido
Evite junho a agosto - per√≠odo mais chuvoso

üéØ ATRA√á√ïES IMPERD√çVEIS:
‚Ä¢ Centro hist√≥rico e Marco Zero
‚Ä¢ Praia de Boa Viagem
‚Ä¢ Instituto Ricardo Brennand
‚Ä¢ Oficina Cer√¢mica

üçΩÔ∏è GASTRONOMIA LOCAL:
‚Ä¢ Tapioca de queijo coalho
‚Ä¢ Caldinho de feij√£o
‚Ä¢ Cartola (sobremesa)
‚Ä¢ √Ågua de coco gelada

üí° DICAS IMPORTANTES:
‚Ä¢ Protetor solar FPS 60+
‚Ä¢ Repelente para passeios
‚Ä¢ Roupas leves e confort√°veis
‚Ä¢ Documento com foto sempre

üì± Entre em contato para mais informa√ß√µes espec√≠ficas!`;
}

// ================================================================================
// üöÄ LOGS E INICIALIZA√á√ÉO
// ================================================================================

console.log("üöÄ CVC API v7.7 - MODULAR FUNCIONAL INICIALIZADA");
console.log("‚úÖ Recursos implementados:");
console.log("- üîß Importa√ß√£o din√¢mica de m√≥dulos (resolve ES6/CommonJS)");
console.log("- üîÑ Fallbacks robustos em todas as etapas");
console.log("- üìã Templates do manual integrados");
console.log("- üéØ Detec√ß√£o autom√°tica de tipos");
console.log("- ü§ñ IA opcional para refinamento");
console.log("- üõ°Ô∏è Sistema √† prova de falhas");
console.log("- üé® Formata√ß√£o profissional garantida");
