// ===== VERS√ÉO CORRIGIDA - CVC ITAQUA API =====
// ================================================================================
// üèÜ CVC ITAQUA - API H√çBRIDA CORRIGIDA
// ================================================================================
// Vers√£o: 4.3.0-fix
// Principais corre√ß√µes:
// 1. Valida√ß√£o rigorosa de dados para evitar "undefined properties"
// 2. Template melhorado para detectar voos somente de ida
// 3. Fallback robusto entre modelos
// 4. Logs melhorados para debugging
// ================================================================================

const templates = {
  'A√©reo M√∫ltiplas Op√ß√µes': `*Passagens A√©reas - Op√ß√µes Dispon√≠veis*

üìã *OP√á√ÉO 1: [COMPANHIA_1]*
üóìÔ∏è [DATA_IDA_1] ([TIPO_VIAGEM_1])
‚úàÔ∏è Ida: [DATA_IDA_1] - [AEROPORTO_ORIGEM_1] [HORA_IDA_1] / [AEROPORTO_DESTINO_1] [HORA_CHEGADA_1]
[VOLTA_1]
üí∞ R$ [VALOR_TOTAL_1] para [COMPOSICAO_PASSAGEIROS_1]
üí≥ [FORMA_PAGAMENTO_1]
üîó [LINK_CVC_1]

üìã *OP√á√ÉO 2: [COMPANHIA_2]*
üóìÔ∏è [DATA_IDA_2] ([TIPO_VIAGEM_2])
‚úàÔ∏è Ida: [DATA_IDA_2] - [AEROPORTO_ORIGEM_2] [HORA_IDA_2] / [AEROPORTO_DESTINO_2] [HORA_CHEGADA_2]
[VOLTA_2]
üí∞ R$ [VALOR_TOTAL_2] para [COMPOSICAO_PASSAGEIROS_2]
üí≥ [FORMA_PAGAMENTO_2]
üîó [LINK_CVC_2]

‚ö†Ô∏è Valores sujeitos a altera√ß√£o e disponibilidade!

üìû D√∫vidas? Estamos aqui para ajudar!`,

  'A√©reo Facial': `*Passagem A√©rea*
üè∑Ô∏è [COMPANHIA_AEREA]
üóìÔ∏è [DATA_IDA] ([TIPO_VIAGEM])
‚úàÔ∏è Ida: [DATA_IDA] - [AEROPORTO_ORIGEM] [HORA_SAIDA] / [AEROPORTO_DESTINO] [HORA_CHEGADA]
[VOLTA_INFO]

üí∞ R$ [VALOR_TOTAL] para [COMPOSICAO_PASSAGEIROS]
üí≥ [FORMA_PAGAMENTO]
üîó [LINK_CVC]

‚ö†Ô∏è Valores sujeitos a altera√ß√£o e disponibilidade!`,

  'Hotel': `*Hospedagem*
üè® [NOME_HOTEL] - [CATEGORIA_ESTRELAS]‚≠ê
üìç [LOCALIZACAO_HOTEL]
üóìÔ∏è [DATA_CHECK_IN] a [DATA_CHECK_OUT] ([QTDE_NOITES] noites)
üë• [QTDE_ADULTOS] adultos[QTDE_CRIANCAS_TEXTO]

üè† *Acomoda√ß√£o:*
[TIPO_QUARTO] com [REGIME_ALIMENTACAO]

‚úÖ *Inclui:*
‚Ä¢ [TIPO_CAFE]
‚Ä¢ [WIFI_INCLUSO]
‚Ä¢ [SERVICOS_INCLUSOS]

üí∞ R$ [VALOR_TOTAL_HOSPEDAGEM] para toda a estadia
üí≥ Parcelamento: [QTDE_PARCELAS]x de R$ [VALOR_PARCELA_HOTEL]

‚ö†Ô∏è Tarifas sujeitas √† disponibilidade.`
};

const aeroportos = {
  'CGH': 'Congonhas', 'GRU': 'Guarulhos', 'VCP': 'Viracopos',
  'SDU': 'Santos Dumont', 'GIG': 'Gale√£o', 'RAO': 'Ribeir√£o Preto',
  'BSB': 'Bras√≠lia', 'CNF': 'Confins', 'PLU': 'Pampulha',
  'CWB': 'Afonso Pena', 'IGU': 'Foz do Igua√ßu', 'REC': 'Recife',
  'FOR': 'Fortaleza', 'MAO': 'Manaus', 'BEL': 'Bel√©m',
  'CGB': 'Cuiab√°', 'CGR': 'Campo Grande', 'AJU': 'Aracaju',
  'MCZ': 'Macei√≥', 'JPA': 'Jo√£o Pessoa', 'NAT': 'Natal',
  'THE': 'Teresina', 'SLZ': 'S√£o Lu√≠s', 'VIX': 'Vit√≥ria',
  'FLN': 'Florian√≥polis', 'POA': 'Porto Alegre', 'BPS': 'Porto Seguro',
  'SSA': 'Salvador', 'IOS': 'Ilh√©us'
};

const PRECOS_MODELOS = {
  'gpt-4o': { input: 0.005, output: 0.015 },
  'gpt-4o-mini': { input: 0.00015, output: 0.0006 },
  'claude-3-5-sonnet-20240620': { input: 0.003, output: 0.015 }
};

const USD_TO_BRL = 5.2;
const MAX_TOKENS = 2500;

// ================================================================================
// üéØ HANDLER PRINCIPAL COM VALIDA√á√ÉO RIGOROSA
// ================================================================================

export default async function handler(req, res) {
  const startTime = Date.now();
  
  try {
    console.log('[HANDLER-FIX] Iniciando processamento da requisi√ß√£o...');
    
    // Configura√ß√£o de CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
    res.setHeader('Content-Type', 'application/json; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');

    if (req.method === 'OPTIONS') {
      console.log('[HANDLER-FIX] Requisi√ß√£o OPTIONS - enviando CORS OK');
      return res.status(200).json({ message: 'CORS OK' });
    }

    if (req.method === 'GET') {
      console.log('[HANDLER-FIX] Requisi√ß√£o GET - enviando status');
      return res.status(200).json({
        message: 'CVC Itaqua API H√≠brida (Vers√£o Corrigida)',
        version: '4.3.0-fix',
        status: 'online',
        modelos: {
          texto: 'gpt-4o-mini',
          imagem: 'claude-3-5-sonnet-20240620',
          fallback: 'gpt-4o'
        },
        timestamp: new Date().toISOString()
      });
    }

    if (req.method !== 'POST') {
      console.error(`[HANDLER-FIX] M√©todo n√£o permitido: ${req.method}`);
      return res.status(405).json({ 
        success: false,
        error: 'M√©todo n√£o permitido' 
      });
    }

    // VALIDA√á√ÉO RIGOROSA DO CORPO DA REQUISI√á√ÉO
    console.log('[HANDLER-FIX] Validando dados recebidos...');
    
    if (!req.body || typeof req.body !== 'object') {
      console.error('[HANDLER-FIX] Corpo da requisi√ß√£o inv√°lido:', typeof req.body);
      return res.status(400).json({
        success: false,
        error: 'Corpo da requisi√ß√£o obrigat√≥rio e deve ser um objeto JSON v√°lido'
      });
    }

    const { prompt, temImagem, arquivo, tipo } = req.body;

    // Valida√ß√£o do prompt
    if (!prompt || typeof prompt !== 'string' || prompt.trim().length === 0) {
      console.error('[HANDLER-FIX] Prompt inv√°lido:', typeof prompt, prompt?.length);
      return res.status(400).json({
        success: false,
        error: 'Prompt obrigat√≥rio e deve ser uma string n√£o vazia'
      });
    }

    // Valida√ß√£o de imagem se especificada
    if (temImagem === true) {
      if (!arquivo || typeof arquivo !== 'string') {
        console.error('[HANDLER-FIX] Arquivo de imagem inv√°lido');
        return res.status(400).json({
          success: false,
          error: 'Arquivo de imagem obrigat√≥rio quando temImagem=true'
        });
      }

      if (!arquivo.startsWith('data:image/')) {
        console.error('[HANDLER-FIX] Formato de imagem inv√°lido');
        return res.status(400).json({
          success: false,
          error: 'Arquivo deve ser uma imagem em formato base64 v√°lido'
        });
      }
    }

    console.log(`[HANDLER-FIX] Dados validados: Prompt=${prompt.length} chars, TemImagem=${temImagem}, Tipo=${tipo}`);

    // PROCESSAMENTO PRINCIPAL
    const { modelo, estrategia, fallback } = selecionarModeloHibrido(temImagem);
    console.log(`[HANDLER-FIX] Estrat√©gia selecionada: ${estrategia}, Modelo: ${modelo}, Fallback: ${fallback}`);

    const template = selecionarTemplate(req.body);
    const isMultiple = detectarMultiplasOpcoes(prompt);
    const promptFinal = construirPromptOtimizado({ temImagem, promptBase: prompt, template, isMultiple });

    console.log(`[HANDLER-FIX] M√∫ltiplas op√ß√µes detectadas: ${isMultiple}`);

    // Chamada para IA com tratamento robusto de erros
    const resultado = await chamarIAHibridaSegura(promptFinal, temImagem, arquivo, modelo, fallback);
    
    if (!resultado || !resultado.content) {
      throw new Error('Resposta da IA est√° vazia ou inv√°lida');
    }

    console.log(`[HANDLER-FIX] IA respondeu com sucesso: Modelo=${resultado.modelo_usado}, Conte√∫do=${resultado.content.length} chars`);

    const responseProcessada = processarResposta(resultado.content);
    const metricas = calcularMetricasHibridas(resultado, startTime, estrategia);

    console.log(`[HANDLER-FIX] Processamento conclu√≠do em ${Date.now() - startTime}ms`);

    return res.status(200).json({
      success: true,
      choices: [{ 
        message: { 
          content: responseProcessada 
        } 
      }],
      metricas: metricas
    });

  } catch (error) {
    console.error('üí• [ERRO CR√çTICO NO HANDLER-FIX] üí•');
    console.error('Erro:', error.message);
    console.error('Stack:', error.stack);
    console.error('Tempo decorrido:', Date.now() - startTime, 'ms');

    return res.status(500).json({
      success: false,
      error: {
        message: `Erro no servidor: ${error.message}`,
        type: 'SERVER_ERROR',
        timestamp: new Date().toISOString(),
        version: '4.3.0-fix'
      }
    });
  }
}

// ================================================================================
// ü§ñ SISTEMA H√çBRIDO COM TRATAMENTO ROBUSTO DE ERROS
// ================================================================================

function selecionarModeloHibrido(temImagem) {
  if (temImagem === true) {
    return {
      modelo: 'claude-3-5-sonnet-20240620',
      estrategia: 'Claude 3.5 Sonnet para an√°lise visual',
      fallback: 'gpt-4o'
    };
  } else {
    return {
      modelo: 'gpt-4o-mini',
      estrategia: 'GPT-4o-mini para processamento de texto',
      fallback: 'gpt-4o'
    };
  }
}

async function chamarIAHibridaSegura(prompt, temImagem, arquivo, modelo, fallbackModelo) {
  let ultimoErro = null;

  try {
    console.log(`[IA-H√çBRIDA-SEGURA] Tentativa 1: ${modelo}`);
    
    if (temImagem === true) {
      return await chamarClaudeSeguro(prompt, arquivo, modelo);
    } else {
      return await chamarOpenAISegura(prompt, false, null, modelo);
    }
    
  } catch (erro1) {
    console.error(`‚ùå [IA-H√çBRIDA-SEGURA] Falha no modelo principal (${modelo}):`, erro1.message);
    ultimoErro = erro1;

    try {
      console.log(`üîÑ [IA-H√çBRIDA-SEGURA] Tentativa 2: ${fallbackModelo}`);
      
      // Para fallback, sempre usar OpenAI (que suporta tanto texto quanto imagem)
      return await chamarOpenAISegura(prompt, temImagem, arquivo, fallbackModelo);
      
    } catch (erro2) {
      console.error(`‚ùå [IA-H√çBRIDA-SEGURA] Falha no fallback (${fallbackModelo}):`, erro2.message);
      
      // √öltima tentativa: GPT-4o-mini apenas texto (ignorando imagem)
      try {
        console.log(`üÜò [IA-H√çBRIDA-SEGURA] Tentativa 3: GPT-4o-mini (somente texto)`);
        return await chamarOpenAISegura(prompt, false, null, 'gpt-4o-mini');
        
      } catch (erro3) {
        console.error(`‚ùå [IA-H√çBRIDA-SEGURA] Falha final:`, erro3.message);
        
        throw new Error(
          `Todos os modelos falharam. ` +
          `Principal (${modelo}): ${erro1.message}. ` +
          `Fallback (${fallbackModelo}): ${erro2.message}. ` +
          `Emerg√™ncia: ${erro3.message}`
        );
      }
    }
  }
}

// ================================================================================
// üèóÔ∏è PROMPTS OTIMIZADOS COM DETEC√á√ÉO DE TIPO DE VIAGEM
// ================================================================================

function construirPromptOtimizado({ temImagem, promptBase, template, isMultiple }) {
  if (temImagem === true) {
    return construirPromptClaude(promptBase, template, isMultiple);
  }
  return construirPromptGPTMini(promptBase, template, isMultiple);
}

function construirPromptClaude(promptBase, template, isMultiple) {
  return `Voc√™ √© um assistente especializado em extrair dados de or√ßamentos de viagem de imagens.

IMPORTANTE: Analise a imagem fornecida e extraia os dados reais. A imagem √© a fonte prim√°ria.

TEMPLATE DE SA√çDA:
${template}

INSTRU√á√ïES ESPEC√çFICAS:
1. **TIPO DE VIAGEM**: Determine se √©:
   - Somente IDA (sem volta): Use "[TIPO_VIAGEM]" = "Somente ida"
   - IDA E VOLTA: Use "[TIPO_VIAGEM]" = "X dias e Y noites"

2. **VOLTA**: 
   - Se for SOMENTE IDA: Use "[VOLTA_INFO]" = "" (vazio)
   - Se for IDA E VOLTA: Use "‚úàÔ∏è Volta: [DATA] - [ORIGEM] [HORA] / [DESTINO] [HORA]"

3. **M√öLTIPLAS OP√á√ïES**: ${isMultiple ? "A imagem cont√©m v√°rias op√ß√µes. Crie se√ß√µes separadas (OP√á√ÉO 1, OP√á√ÉO 2...)." : "A imagem cont√©m uma √∫nica op√ß√£o."}

4. **DADOS CONTEXTUAIS**: ${promptBase}

5. **CONVERS√ÉO DE AEROPORTOS**: Converta siglas (ex: VCP ‚Üí Viracopos, BSB ‚Üí Bras√≠lia)

Responda APENAS com o template preenchido, sem coment√°rios adicionais.`;
}

function construirPromptGPTMini(promptBase, template, isMultiple) {
  return `Voc√™ √© um assistente da CVC especializado em formatar or√ßamentos de viagem.

TEMPLATE OBRIGAT√ìRIO:
${template}

DADOS DO CLIENTE:
${promptBase}

REGRAS IMPORTANTES:
1. **DETEC√á√ÉO DE TIPO**: Analise se √©:
   - SOMENTE IDA: Use "[TIPO_VIAGEM]" = "Somente ida" e "[VOLTA_INFO]" = ""
   - IDA E VOLTA: Use "[TIPO_VIAGEM]" = "X dias" e inclua linha de volta

2. **EXEMPLO DE IDA**:
   üóìÔ∏è 01 de agosto (Somente ida)
   ‚úàÔ∏è Ida: 01/ago - Viracopos 17:55 / Bras√≠lia 19:30

3. **EXEMPLO IDA E VOLTA**:
   üóìÔ∏è 05 de mar - 15 de mar (11 dias e 10 noites)
   ‚úàÔ∏è Ida: 05/mar - Guarulhos 01:50 / Orlando 12:15
   ‚úàÔ∏è Volta: 15/mar - Orlando 14:55 / Guarulhos 05:50

4. **M√öLTIPLAS OP√á√ïES**: ${isMultiple ? "Formate todas as op√ß√µes encontradas." : "Formate a √∫nica op√ß√£o."}

5. **AEROPORTOS**: Converta siglas para nomes completos (VCP ‚Üí Viracopos, BSB ‚Üí Bras√≠lia, etc.)

Responda APENAS com o template preenchido, sem explica√ß√µes extras.`;
}

function detectarMultiplasOpcoes(prompt) {
  if (!prompt || typeof prompt !== 'string') return false;
  
  const texto = prompt.toLowerCase();
  const precos = (texto.match(/r\$.*\d/g) || []).length;
  const cias = (texto.match(/(gol|latam|azul|avianca|tap)/gi) || []).length;
  const totais = (texto.match(/total.*\d+.*adult/gi) || []).length;
  const links = (texto.match(/https:\/\/www\.cvc\.com\.br\/carrinho/gi) || []).length;
  
  return precos >= 2 || cias >= 2 || totais >= 2 || links >= 2;
}

function selecionarTemplate({ tipos, prompt }) {
  // Valida√ß√£o segura
  if (!tipos || !Array.isArray(tipos)) tipos = ['A√©reo Facial'];
  if (!prompt) prompt = '';
  
  if (detectarMultiplasOpcoes(prompt) && tipos.includes('A√©reo Facial')) {
    return templates['A√©reo M√∫ltiplas Op√ß√µes'];
  }
  
  const primeiroTipo = tipos[0] || 'A√©reo Facial';
  return templates[primeiroTipo] || templates['A√©reo Facial'];
}

// ================================================================================
// üü† CHAMADA CLAUDE SEGURA
// ================================================================================

async function chamarClaudeSeguro(prompt, arquivo, modelo) {
  console.log(`[CLAUDE-SEGURO] Preparando chamada para ${modelo}...`);
  
  // Valida√ß√£o de API Key
  if (!process.env.ANTHROPIC_API_KEY) {
    throw new Error('ANTHROPIC_API_KEY n√£o encontrada nas vari√°veis de ambiente');
  }

  // Valida√ß√£o rigorosa do arquivo
  if (!arquivo || typeof arquivo !== 'string') {
    throw new Error('Arquivo base64 obrigat√≥rio para Claude');
  }

  const base64Match = arquivo.match(/data:(image\/[^;]+);base64,(.+)/);
  if (!base64Match || !base64Match[1] || !base64Match[2]) {
    throw new Error('Formato de imagem base64 inv√°lido. Esperado: data:image/...;base64,...');
  }

  const mimeType = base64Match[1];
  const base64Data = base64Match[2];

  // Validar tipos suportados
  const tiposSuportados = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'];
  if (!tiposSuportados.includes(mimeType)) {
    throw new Error(`Tipo de imagem n√£o suportado: ${mimeType}. Suportados: ${tiposSuportados.join(', ')}`);
  }

  // Verificar tamanho da imagem
  const tamanhoBytes = (base64Data.length * 3) / 4;
  const tamanhoMB = tamanhoBytes / (1024 * 1024);
  if (tamanhoMB > 5) {
    throw new Error(`Imagem muito grande: ${tamanhoMB.toFixed(2)}MB. M√°ximo: 5MB`);
  }

  const content = [
    { type: "text", text: prompt },
    {
      type: "image",
      source: {
        type: "base64",
        media_type: mimeType,
        data: base64Data
      }
    }
  ];

  console.log(`[CLAUDE-SEGURO] Enviando requisi√ß√£o - Prompt: ${prompt.length} chars, Imagem: ${tamanhoMB.toFixed(2)}MB`);

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'x-api-key': process.env.ANTHROPIC_API_KEY,
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: modelo,
        max_tokens: MAX_TOKENS,
        messages: [{ role: 'user', content }]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[CLAUDE-SEGURO] Erro HTTP ${response.status}:`, errorText);
      
      let errorMessage = `Erro Claude ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.error?.message || errorMessage;
      } catch (e) {
        errorMessage += `: ${errorText.substring(0, 200)}`;
      }
      
      throw new Error(errorMessage);
    }

    const data = await response.json();
    
    // Valida√ß√£o rigorosa da resposta
    if (!data || typeof data !== 'object') {
      throw new Error('Resposta Claude inv√°lida: n√£o √© um objeto JSON');
    }

    if (!data.content || !Array.isArray(data.content) || data.content.length === 0) {
      throw new Error('Resposta Claude inv√°lida: campo content ausente ou vazio');
    }

    if (!data.content[0] || typeof data.content[0] !== 'object' || !data.content[0].text) {
      throw new Error('Resposta Claude inv√°lida: texto da resposta ausente');
    }

    const usage = data.usage || { input_tokens: 0, output_tokens: 0 };
    console.log(`[CLAUDE-SEGURO] Sucesso - Tokens: input=${usage.input_tokens}, output=${usage.output_tokens}`);

    return {
      content: data.content[0].text,
      usage: usage,
      modelo_usado: modelo
    };

  } catch (error) {
    console.error(`[CLAUDE-SEGURO] Erro na requisi√ß√£o:`, error.message);
    throw error;
  }
}

// ================================================================================
// üîµ CHAMADA OPENAI SEGURA
// ================================================================================

async function chamarOpenAISegura(prompt, temImagem, arquivo, modelo) {
  console.log(`[OPENAI-SEGURO] Preparando chamada para ${modelo}...`);
  
  // Valida√ß√£o de API Key
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OPENAI_API_KEY n√£o encontrada nas vari√°veis de ambiente');
  }

  let messages;

  if (temImagem === true && arquivo) {
    // Validar formato da imagem
    if (!arquivo.startsWith('data:image/')) {
      throw new Error('Formato de imagem inv√°lido para OpenAI');
    }

    messages = [
      {
        role: "user",
        content: [
          { type: "text", text: prompt },
          { type: "image_url", image_url: { url: arquivo } }
        ]
      }
    ];
    console.log(`[OPENAI-SEGURO] Modo imagem - Arquivo: ${arquivo.length} chars`);
  } else {
    messages = [{ role: "user", content: prompt }];
    console.log(`[OPENAI-SEGURO] Modo texto - Prompt: ${prompt.length} chars`);
  }

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: modelo,
        messages: messages,
        max_tokens: MAX_TOKENS,
        temperature: 0.1
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[OPENAI-SEGURO] Erro HTTP ${response.status}:`, errorText);
      
      let errorMessage = `Erro OpenAI ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.error?.message || errorMessage;
      } catch (e) {
        errorMessage += `: ${errorText.substring(0, 200)}`;
      }
      
      throw new Error(errorMessage);
    }

    const data = await response.json();

    // Valida√ß√£o rigorosa da resposta
    if (!data || typeof data !== 'object') {
      throw new Error('Resposta OpenAI inv√°lida: n√£o √© um objeto JSON');
    }

    if (!data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
      throw new Error('Resposta OpenAI inv√°lida: campo choices ausente ou vazio');
    }

    if (!data.choices[0] || typeof data.choices[0] !== 'object' || !data.choices[0].message) {
      throw new Error('Resposta OpenAI inv√°lida: message ausente na primeira choice');
    }

    if (!data.choices[0].message.content) {
      throw new Error('Resposta OpenAI inv√°lida: content ausente na message');
    }

    const usage = data.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };
    console.log(`[OPENAI-SEGURO] Sucesso - Tokens: ${usage.total_tokens}`);

    return {
      content: data.choices[0].message.content,
      usage: usage,
      modelo_usado: modelo
    };

  } catch (error) {
    console.error(`[OPENAI-SEGURO] Erro na requisi√ß√£o:`, error.message);
    throw error;
  }
}

// ================================================================================
// üîß PROCESSAMENTO E UTILIT√ÅRIOS
// ================================================================================

function processarResposta(response) {
  if (!response || typeof response !== 'string') {
    return 'Erro: Resposta da IA est√° vazia ou inv√°lida';
  }

  let processada = response
    .replace(/TEMPLATE DE SA√çDA:.*?\n/gi, '')
    .replace(/TEMPLATE OBRIGAT√ìRIO:.*?\n/gi, '')
    .trim();

  // Convers√£o de aeroportos
  Object.entries(aeroportos).forEach(([sigla, nome]) => {
    const regex = new RegExp(`\\b${sigla}\\b`, 'gi');
    processada = processada.replace(regex, nome);
  });

  return processada.replace(/\n\s*\n/g, '\n\n').trim();
}

function calcularMetricasHibridas(resultado, startTime, estrategia) {
  // Valida√ß√£o de entrada
  if (!resultado || typeof resultado !== 'object') {
    return {
      erro: 'Resultado inv√°lido para c√°lculo de m√©tricas',
      tempo_processamento_ms: Date.now() - startTime
    };
  }

  const tokensInput = resultado.usage?.prompt_tokens || resultado.usage?.input_tokens || 0;
  const tokensOutput = resultado.usage?.completion_tokens || resultado.usage?.output_tokens || 0;
  const modeloUsado = resultado.modelo_usado || 'desconhecido';
  
  const precosModelo = PRECOS_MODELOS[modeloUsado] || { input: 0, output: 0 };
  
  const custoUSD = (tokensInput / 1000) * precosModelo.input + (tokensOutput / 1000) * precosModelo.output;
  const custoBRL = custoUSD * USD_TO_BRL;

  // C√°lculo de economia vs GPT-4o
  const custoGPT4o = (tokensInput / 1000) * PRECOS_MODELOS['gpt-4o'].input + 
                     (tokensOutput / 1000) * PRECOS_MODELOS['gpt-4o'].output;
  const economiaUSD = custoGPT4o - custoUSD;
  const economiaBRL = economiaUSD * USD_TO_BRL;
  
  return {
    modelo_usado: modeloUsado,
    estrategia: estrategia,
    tokens: {
      input: tokensInput,
      output: tokensOutput,
      total: tokensInput + tokensOutput
    },
    custo: {
      usd: custoUSD,
      brl: custoBRL
    },
    economia: {
      vs_gpt4o_usd: economiaUSD,
      vs_gpt4o_brl: economiaBRL,
      percentual: custoGPT4o > 0 ? ((economiaUSD / custoGPT4o) * 100).toFixed(1) + '%' : '0%'
    },
    performance: {
      tempo_processamento_ms: Date.now() - startTime
    }
  };
}

// ================================================================================
// üß™ FUN√á√ïES DE TESTE E DEBUG
// ================================================================================

function validarRequest(req) {
  const erros = [];
  
  if (!req.body) {
    erros.push('Corpo da requisi√ß√£o ausente');
  }
  
  if (!req.body.prompt || typeof req.body.prompt !== 'string') {
    erros.push('Prompt obrigat√≥rio e deve ser string');
  }
  
  if (req.body.temImagem === true && !req.body.arquivo) {
    erros.push('Arquivo obrigat√≥rio quando temImagem=true');
  }
  
  return {
    valido: erros.length === 0,
    erros: erros
  };
}

function logDebug(contexto, dados) {
  console.log(`[DEBUG-${contexto}]`, {
    timestamp: new Date().toISOString(),
    ...dados
  });
}

// ================================================================================
// üìä AN√ÅLISE ESPEC√çFICA PARA VOOS SOMENTE IDA
// ================================================================================

function analisarTipoViagem(texto) {
  if (!texto || typeof texto !== 'string') {
    return { tipo: 'desconhecido', confianca: 0 };
  }
  
  const textoLower = texto.toLowerCase();
  
  // Indicadores de ida e volta
  const indicadoresIdaVolta = [
    /ida.*volta/gi,
    /ida.*retorno/gi,
    /partida.*retorno/gi,
    /\d+ dias.*\d+ noites/gi,
    /ida.*\d{2}\/\d{2}.*volta.*\d{2}\/\d{2}/gi
  ];
  
  // Indicadores de somente ida
  const indicadoresSomenteIda = [
    /somente ida/gi,
    /s√≥ ida/gi,
    /one way/gi,
    /ida\s*$/gi
  ];
  
  // Contar voos de volta expl√≠citos
  const voosVolta = (textoLower.match(/volta.*\d{2}:\d{2}/gi) || []).length;
  const datasVolta = (textoLower.match(/volta.*\d{2}\/\d{2}/gi) || []).length;
  
  // An√°lise
  let pontuacaoIdaVolta = 0;
  let pontuacaoSomenteIda = 0;
  
  indicadoresIdaVolta.forEach(regex => {
    if (regex.test(textoLower)) pontuacaoIdaVolta += 2;
  });
  
  indicadoresSomenteIda.forEach(regex => {
    if (regex.test(textoLower)) pontuacaoSomenteIda += 3;
  });
  
  pontuacaoIdaVolta += voosVolta + datasVolta;
  
  // Decis√£o final
  if (pontuacaoSomenteIda > pontuacaoIdaVolta) {
    return { tipo: 'somente_ida', confianca: pontuacaoSomenteIda };
  } else if (pontuacaoIdaVolta > 0) {
    return { tipo: 'ida_volta', confianca: pontuacaoIdaVolta };
  } else {
    // Se n√£o h√° indicadores claros, assumir ida e volta se houver m√∫ltiplas datas
    const datas = (textoLower.match(/\d{2}\/\d{2}|\d{2} de \w+/gi) || []).length;
    return { 
      tipo: datas >= 2 ? 'ida_volta' : 'somente_ida', 
      confianca: 1 
    };
  }
}

// ================================================================================
// üîÑ SISTEMA DE RETRY INTELIGENTE
// ================================================================================

async function executarComRetry(funcao, maxTentativas = 3, delayMs = 1000) {
  let ultimoErro = null;
  
  for (let tentativa = 1; tentativa <= maxTentativas; tentativa++) {
    try {
      console.log(`[RETRY] Tentativa ${tentativa}/${maxTentativas}`);
      const resultado = await funcao();
      console.log(`[RETRY] Sucesso na tentativa ${tentativa}`);
      return resultado;
    } catch (error) {
      console.error(`[RETRY] Falha na tentativa ${tentativa}:`, error.message);
      ultimoErro = error;
      
      if (tentativa < maxTentativas) {
        const delay = delayMs * tentativa; // Delay progressivo
        console.log(`[RETRY] Aguardando ${delay}ms antes da pr√≥xima tentativa...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Falha ap√≥s ${maxTentativas} tentativas. √öltimo erro: ${ultimoErro.message}`);
}

// ================================================================================
// üéØ TEMPLATES ESPEC√çFICOS PARA DIFERENTES CEN√ÅRIOS
// ================================================================================

const templatesEspecificos = {
  somenteIda: `*Passagem A√©rea - Somente Ida*
üè∑Ô∏è [COMPANHIA_AEREA]
üóìÔ∏è [DATA_IDA] (Somente ida)
‚úàÔ∏è [DATA_IDA] - [AEROPORTO_ORIGEM] [HORA_SAIDA] / [AEROPORTO_DESTINO] [HORA_CHEGADA]

üí∞ R$ [VALOR_TOTAL] para [COMPOSICAO_PASSAGEIROS]
üí≥ [FORMA_PAGAMENTO]
üîó [LINK_CVC]

‚ö†Ô∏è Passagem somente de ida - sem retorno inclu√≠do`,

  idaVolta: `*Passagem A√©rea - Ida e Volta*
üè∑Ô∏è [COMPANHIA_AEREA]
üóìÔ∏è [DATA_IDA] a [DATA_VOLTA] ([DURACAO])
‚úàÔ∏è Ida: [DATA_IDA] - [AEROPORTO_ORIGEM] [HORA_IDA] / [AEROPORTO_DESTINO] [HORA_CHEGADA_IDA]
‚úàÔ∏è Volta: [DATA_VOLTA] - [AEROPORTO_ORIGEM_VOLTA] [HORA_SAIDA_VOLTA] / [AEROPORTO_DESTINO_VOLTA] [HORA_CHEGADA_VOLTA]

üí∞ R$ [VALOR_TOTAL] para [COMPOSICAO_PASSAGEIROS]
üí≥ [FORMA_PAGAMENTO]
üîó [LINK_CVC]

‚ö†Ô∏è Ida e volta inclu√≠dos no valor`
};

function selecionarTemplateInteligente(dados) {
  const { prompt, tipos } = dados;
  
  if (!tipos || !tipos.includes('A√©reo Facial')) {
    return templates[tipos?.[0]] || templates['A√©reo Facial'];
  }
  
  // An√°lise do tipo de viagem
  const analiseViagem = analisarTipoViagem(prompt);
  const isMultiple = detectarMultiplasOpcoes(prompt);
  
  console.log(`[TEMPLATE-INTELIGENTE] Tipo: ${analiseViagem.tipo}, M√∫ltiplas: ${isMultiple}`);
  
  if (isMultiple) {
    return templates['A√©reo M√∫ltiplas Op√ß√µes'];
  }
  
  if (analiseViagem.tipo === 'somente_ida') {
    return templatesEspecificos.somenteIda;
  } else {
    return templatesEspecificos.idaVolta;
  }
}

// ================================================================================
// üîß FUN√á√ïES AUXILIARES MELHORADAS
// ================================================================================

function sanitizarTexto(texto) {
  if (!texto || typeof texto !== 'string') return '';
  
  return texto
    .replace(/[^\w\s\-√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√ø]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function extrairInformacoesVoo(texto) {
  if (!texto) return {};
  
  const regexes = {
    companhia: /(gol|latam|azul|avianca|tap|american|united)/gi,
    preco: /r\$\s*[\d.,]+/gi,
    horario: /\d{2}:\d{2}/g,
    data: /\d{2}\/\d{2}|\d{2} de \w+/gi,
    aeroporto: /\b(cgr|gru|vcp|sdu|gig|bsb|cnf|cwb|rao|rec|for|ssa)\b/gi
  };
  
  const resultados = {};
  
  Object.entries(regexes).forEach(([chave, regex]) => {
    const matches = texto.match(regex);
    resultados[chave] = matches || [];
  });
  
  return resultados;
}

// ================================================================================
// üìà M√âTRICAS E MONITORAMENTO
// ================================================================================

let contadorRequisicoes = 0;
let contadorErros = 0;
let tempoTotalProcessamento = 0;

function atualizarEstatisticas(tempoProcessamento, sucesso = true) {
  contadorRequisicoes++;
  tempoTotalProcessamento += tempoProcessamento;
  
  if (!sucesso) {
    contadorErros++;
  }
  
  console.log(`[ESTAT√çSTICAS] Requisi√ß√µes: ${contadorRequisicoes}, Erros: ${contadorErros}, Tempo m√©dio: ${(tempoTotalProcessamento / contadorRequisicoes).toFixed(2)}ms`);
}

function obterEstatisticas() {
  return {
    total_requisicoes: contadorRequisicoes,
    total_erros: contadorErros,
    taxa_sucesso: contadorRequisicoes > 0 ? ((contadorRequisicoes - contadorErros) / contadorRequisicoes * 100).toFixed(2) + '%' : '0%',
    tempo_medio_ms: contadorRequisicoes > 0 ? (tempoTotalProcessamento / contadorRequisicoes).toFixed(2) : 0
  };
}

// ================================================================================
// üèÅ EXPORTA√á√ÉO E LOGS FINAIS
// ================================================================================

console.log('‚úÖ [SISTEMA-CORRIGIDO] CVC Itaqua API v4.3.0-fix carregada');
console.log('üîß [MELHORIAS] Valida√ß√£o rigorosa, detec√ß√£o de ida/volta, fallback robusto');
console.log('üéØ [RECURSOS] Templates inteligentes, retry autom√°tico, logs detalhados');

// Para debug em desenvolvimento
if (process.env.NODE_ENV === 'development') {
  console.log('üß™ [DEBUG] Modo desenvolvimento ativo - logs extras habilitados');
  
  // Endpoint de estat√≠sticas (apenas em dev)
  global.obterEstatisticasAPI = obterEstatisticas;
  global.resetarEstatisticas = () => {
    contadorRequisicoes = 0;
    contadorErros = 0;
    tempoTotalProcessamento = 0;
    console.log('üìä [DEBUG] Estat√≠sticas resetadas');
  };
}
