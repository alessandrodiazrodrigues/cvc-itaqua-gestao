// üîß api/modules/processing.js - v9.1 - SISTEMA COMPLETO E CORRIGIDO
// Processamento especializado para CVC Itaqua
// CORRE√á√ïES: Extra√ß√£o de datas, hor√°rios e passageiros

console.log("üîß Processing v9.1 - SISTEMA CORRIGIDO PARA CVC ITAQUA");

// ================================================================================
// üìã √çNDICE DE FUN√á√ïES
// ================================================================================
/* 
1Ô∏è‚É£ processarRespostaCompleta()      - Fun√ß√£o principal de processamento
2Ô∏è‚É£ removerCabecalhosTecnicos()      - Remove headers desnecess√°rios
3Ô∏è‚É£ aplicarFormatacaoCompleta()      - Formata√ß√£o profissional
4Ô∏è‚É£ validarRegrasCriticas()          - Valida√ß√£o de regras CVC
5Ô∏è‚É£ aplicarCorrecoesPorTipo()        - Corre√ß√µes espec√≠ficas por tipo
6Ô∏è‚É£ formatarParaWhatsApp()           - Formata√ß√£o final WhatsApp
7Ô∏è‚É£ validarOrcamentoFinal()          - Valida√ß√£o final
8Ô∏è‚É£ calcularMetricasQualidade()      - M√©tricas de qualidade
9Ô∏è‚É£ processarMultiplasOpcoes()       - Processa m√∫ltiplas op√ß√µes
üîü garantirFormatoWhatsApp()        - Garante formato WhatsApp
*/

// ================================================================================
// 1Ô∏è‚É£ FUN√á√ÉO PRINCIPAL - PROCESSAMENTO COMPLETO
// ================================================================================

function processarRespostaCompleta(conteudo, analise, formData) {
  console.log("üîß [1] Iniciando processamento completo v9.1...");
  
  if (!conteudo) {
    console.error("‚ùå [1] Conte√∫do vazio para processar");
    return "‚ùå Erro: N√£o foi poss√≠vel gerar o or√ßamento. Tente novamente.";
  }
  
  let conteudoProcessado = conteudo;
  const respostaOriginal = conteudo; // Guardar original para extra√ß√£o
  
  try {
    // ETAPA 1: Detectar e processar m√∫ltiplas op√ß√µes PRIMEIRO
    if (detectarMultiplasOpcoes(conteudoProcessado)) {
      console.log("üîç [1] M√∫ltiplas op√ß√µes detectadas!");
      conteudoProcessado = processarMultiplasOpcoes(conteudoProcessado, formData);
    }
    
    // ETAPA 2: Remover cabe√ßalhos t√©cnicos
    conteudoProcessado = removerCabecalhosTecnicos(conteudoProcessado);
    
    // ETAPA 3: Aplicar formata√ß√£o completa
    conteudoProcessado = aplicarFormatacaoCompleta(conteudoProcessado);
    
    // ETAPA 4: Validar regras cr√≠ticas
    conteudoProcessado = validarRegrasCriticas(conteudoProcessado);
    
    // ETAPA 5: Aplicar corre√ß√µes por tipo
    if (analise) {
      conteudoProcessado = aplicarCorrecoesPorTipo(conteudoProcessado, analise);
    }
    
    // ETAPA 6: Garantir formato WhatsApp
    conteudoProcessado = garantirFormatoWhatsApp(conteudoProcessado);
    
    // ETAPA 7: Formata√ß√£o final para WhatsApp
    conteudoProcessado = formatarParaWhatsApp(conteudoProcessado);
    
    // ETAPA 8: Corrigir datas, hor√°rios e passageiros
    conteudoProcessado = corrigirDatasHorariosPassageiros(conteudoProcessado, respostaOriginal, formData);
    
    // ETAPA 9: Valida√ß√£o final
    const validacao = validarOrcamentoFinal(conteudoProcessado, formData);
    if (!validacao.valido) {
      console.warn("‚ö†Ô∏è [1] Valida√ß√£o encontrou problemas:", validacao.problemas);
    }
    
    console.log(`‚úÖ [1] Processamento finalizado: ${conteudoProcessado.length} caracteres`);
    return conteudoProcessado;
    
  } catch (error) {
    console.error("‚ùå [1] Erro no processamento:", error);
    return aplicarFormatacaoBasica(conteudo);
  }
}

// ================================================================================
// NOVA FUN√á√ÉO: CORRIGIR DATAS, HOR√ÅRIOS E PASSAGEIROS
// ================================================================================

function corrigirDatasHorariosPassageiros(resultado, respostaOriginal, formData) {
  console.log("üìÖ Corrigindo datas, hor√°rios e passageiros...");
  
  // Extrair datas do formato original
  const datas = extrairDatasVoo(respostaOriginal);
  if (datas) {
    resultado = resultado.replace(/\[DD\/MM\]/g, function(match, offset, string) {
      const count = (string.slice(0, offset).match(/\[DD\/MM\]/g) || []).length;
      return count === 0 ? datas.ida : datas.volta;
    });
  }
  
  // Extrair hor√°rios do formato original
  const horariosMatch = [...respostaOriginal.matchAll(/(\d{2}:\d{2})/g)];
  if (horariosMatch.length >= 4) {
    let horarioIndex = 0;
    resultado = resultado.replace(/\[HH:MM\]/g, () => {
      if (horarioIndex < horariosMatch.length) {
        return horariosMatch[horarioIndex++][0];
      }
      return '[HH:MM]';
    });
  }
  
  // Extrair informa√ß√µes de passageiros corretamente
  const matchPassageiros = respostaOriginal.match(/Total\s*\(([^)]+)\)/i);
  if (matchPassageiros && matchPassageiros[1]) {
    const textoPassageiros = matchPassageiros[1];
    console.log("üë• Texto de passageiros encontrado:", textoPassageiros);
    
    // Extrair n√∫mero de adultos, crian√ßas e beb√™s
    const matchAdultos = textoPassageiros.match(/(\d+)\s*[Aa]dulto/);
    const numeroAdultos = matchAdultos ? parseInt(matchAdultos[1]) : 1;
    
    const matchCriancas = textoPassageiros.match(/(\d+)\s*[Cc]rian√ßa/);
    const numeroCriancas = matchCriancas ? parseInt(matchCriancas[1]) : 0;
    
    const matchBebes = textoPassageiros.match(/(\d+)\s*[Bb]eb√™/);
    const numeroBebes = matchBebes ? parseInt(matchBebes[1]) : 0;
    
    // Construir texto de passageiros
    if (numeroAdultos > 1 || numeroCriancas > 0 || numeroBebes > 0) {
      let textoPassageirosFormatado = [];
      if (numeroAdultos > 0) textoPassageirosFormatado.push(`${numeroAdultos} adulto${numeroAdultos > 1 ? 's' : ''}`);
      if (numeroCriancas > 0) textoPassageirosFormatado.push(`${numeroCriancas} crian√ßa${numeroCriancas > 1 ? 's' : ''}`);
      if (numeroBebes > 0) textoPassageirosFormatado.push(`${numeroBebes} beb√™${numeroBebes > 1 ? 's' : ''}`);
      
      // Atualizar a linha de pre√ßo
      resultado = resultado.replace(
        /üí∞ R\$ ([\d.,]+) para \d+ adulto[s]?/,
        `üí∞ R$ $1 para ${textoPassageirosFormatado.join(', ')}`
      );
    }
  }
  
  return resultado;
}

function extrairDatasVoo(texto) {
  console.log("üìÖ Extraindo datas do voo...");
  
  // Procurar por padr√µes de data como "sex, 19 de dezembro"
  const padraoData = /(\w{3}),?\s*(\d{1,2})\s+de\s+(\w+)/gi;
  const matches = [...texto.matchAll(padraoData)];
  
  const meses = {
    'janeiro': '01', 'fevereiro': '02', 'mar√ßo': '03', 'abril': '04',
    'maio': '05', 'junho': '06', 'julho': '07', 'agosto': '08',
    'setembro': '09', 'outubro': '10', 'novembro': '11', 'dezembro': '12'
  };
  
  if (matches.length >= 2) {
    const dataIda = matches[0];
    const dataVolta = matches[1];
    
    const diaIda = dataIda[2].padStart(2, '0');
    const mesIda = meses[dataIda[3].toLowerCase()] || '01';
    
    const diaVolta = dataVolta[2].padStart(2, '0');
    const mesVolta = meses[dataVolta[3].toLowerCase()] || '01';
    
    console.log(`‚úÖ Datas extra√≠das: ${diaIda}/${mesIda} - ${diaVolta}/${mesVolta}`);
    
    return {
      ida: `${diaIda}/${mesIda}`,
      volta: `${diaVolta}/${mesVolta}`
    };
  }
  
  // Fallback para formato DD/MM
  const padraoSimples = /(\d{1,2})\/(\d{1,2})/g;
  const matchesSimples = [...texto.matchAll(padraoSimples)];
  
  if (matchesSimples.length >= 2) {
    return {
      ida: `${matchesSimples[0][1].padStart(2, '0')}/${matchesSimples[0][2].padStart(2, '0')}`,
      volta: `${matchesSimples[1][1].padStart(2, '0')}/${matchesSimples[1][2].padStart(2, '0')}`
    };
  }
  
  return null;
}

// ================================================================================
// 9Ô∏è‚É£ PROCESSAR M√öLTIPLAS OP√á√ïES - MELHORADO
// ================================================================================

function detectarMultiplasOpcoes(conteudo) {
  const texto = conteudo.toLowerCase();
  return (
    // Detecta Salvador e Porto Seguro (ou outros destinos diferentes)
    (texto.includes('salvador') && texto.includes('porto seguro')) ||
    (texto.includes('fortaleza') && texto.includes('natal')) ||
    (texto.includes('recife') && texto.includes('macei√≥')) ||
    // Detecta m√∫ltiplos valores
    ((conteudo.match(/R\$\s*[\d.,]+/gi) || []).length >= 2) ||
    // Detecta padr√µes de op√ß√µes
    (texto.includes('op√ß√£o 1') && texto.includes('op√ß√£o 2')) ||
    // Detecta m√∫ltiplas companhias
    ((texto.includes('gol') && texto.includes('latam')) ||
     (texto.includes('azul') && texto.includes('latam')))
  );
}

function processarMultiplasOpcoes(conteudo, formData) {
  console.log("üî¢ [9] Processando m√∫ltiplas op√ß√µes...");
  
  // Extrair blocos de informa√ß√£o
  const opcoes = extrairOpcoesDoConteudo(conteudo);
  
  if (opcoes.length < 2) {
    console.log("‚ö†Ô∏è [9] Menos de 2 op√ß√µes detectadas, retornando conte√∫do original");
    return conteudo;
  }
  
  let resultado = '';
  
  // Processar cada op√ß√£o
  opcoes.forEach((opcao, index) => {
    const numeroOpcao = index + 1;
    
    // Formatar cabe√ßalho da op√ß√£o
    resultado += `*OP√á√ÉO ${numeroOpcao} - ${opcao.companhia || 'Companhia'} - S√£o Paulo ‚úà ${opcao.destino}*\n`;
    
    // Adicionar datas e hor√°rios
    if (opcao.dataIda && opcao.horaIda) {
      resultado += `${opcao.dataIda} - ${opcao.origemAeroporto || 'Guarulhos'} ${opcao.horaIda} / ${opcao.destinoAeroporto || opcao.destino} ${opcao.horaChegadaIda || '--:--'} (${opcao.tipoVooIda || 'voo direto'})\n`;
    }
    
    resultado += `--\n`;
    
    if (opcao.dataVolta && opcao.horaVolta) {
      resultado += `${opcao.dataVolta} - ${opcao.destinoAeroporto || opcao.destino} ${opcao.horaVolta} / ${opcao.origemAeroporto || 'Guarulhos'} ${opcao.horaChegadaVolta || '--:--'} (${opcao.tipoVooVolta || 'voo direto'})\n`;
    }
    
    resultado += `\n`;
    
    // Adicionar valor
    resultado += `üí∞ ${opcao.valor || 'R$ 0,00'} para ${formData?.adultos || 4} adulto${(formData?.adultos || 4) > 1 ? 's' : ''}`;
    if (formData?.criancas > 0) {
      resultado += ` + ${formData.criancas} crian√ßa${formData.criancas > 1 ? 's' : ''}`;
    }
    resultado += `\n`;
    
    // Adicionar bagagem
    resultado += `‚úÖ ${opcao.bagagem || 'S√≥ mala de m√£o inclu√≠da'}\n`;
    
    // Adicionar pol√≠tica de reembolso
    resultado += `üè∑Ô∏è ${opcao.reembolso || 'N√£o reembols√°vel'}\n`;
    
    // Separador entre op√ß√µes
    if (numeroOpcao < opcoes.length) {
      resultado += `\n`;
    }
  });
  
  // Adicionar rodap√©
  resultado += `\nValores sujeitos a confirma√ß√£o e disponibilidade`;
  
  console.log(`‚úÖ [9] ${opcoes.length} op√ß√µes formatadas`);
  return resultado;
}

function extrairOpcoesDoConteudo(conteudo) {
  const opcoes = [];
  const blocos = separarBlocosDeVoo(conteudo);
  
  blocos.forEach(bloco => {
    const opcao = {
      companhia: extrairCompanhiaDoBloco(bloco),
      destino: extrairDestinoDoBloco(bloco),
      valor: extrairValorDoBloco(bloco),
      dataIda: extrairDataIda(bloco),
      dataVolta: extrairDataVolta(bloco),
      horaIda: extrairHorario(bloco, 'ida'),
      horaVolta: extrairHorario(bloco, 'volta'),
      horaChegadaIda: extrairHorario(bloco, 'chegada_ida'),
      horaChegadaVolta: extrairHorario(bloco, 'chegada_volta'),
      bagagem: extrairBagagem(bloco),
      reembolso: extrairReembolso(bloco),
      origemAeroporto: 'Guarulhos',
      destinoAeroporto: extrairAeroportoDestino(bloco)
    };
    
    if (opcao.destino && opcao.valor) {
      opcoes.push(opcao);
    }
  });
  
  return opcoes;
}

function separarBlocosDeVoo(conteudo) {
  // Separar por padr√µes que indicam diferentes voos
  let blocos = [conteudo];
  
  // Tentar separar por valores totais
  const valoresMatch = conteudo.match(/total.*?R\$\s*[\d.,]+/gi);
  if (valoresMatch && valoresMatch.length > 1) {
    blocos = [];
    let textoTemp = conteudo;
    valoresMatch.forEach((valor, index) => {
      const pos = textoTemp.indexOf(valor);
      if (pos > 0) {
        blocos.push(textoTemp.substring(0, pos + valor.length));
        textoTemp = textoTemp.substring(pos + valor.length);
      }
    });
  }
  
  return blocos.filter(b => b.trim().length > 50);
}

// ================================================================================
// üîß FUN√á√ïES AUXILIARES DE EXTRA√á√ÉO
// ================================================================================

function extrairCompanhiaDoBloco(bloco) {
  const companhias = ['Gol', 'Latam', 'Azul', 'TAP', 'Avianca', 'Copa'];
  for (const cia of companhias) {
    if (bloco.toLowerCase().includes(cia.toLowerCase())) {
      return cia.toUpperCase();
    }
  }
  return 'LATAM';
}

function extrairDestinoDoBloco(bloco) {
  const destinos = {
    'salvador': 'Salvador',
    'porto seguro': 'Porto Seguro',
    'fortaleza': 'Fortaleza',
    'recife': 'Recife',
    'natal': 'Natal',
    'macei√≥': 'Macei√≥',
    'maceio': 'Macei√≥',
    'florian√≥polis': 'Florian√≥polis',
    'florianopolis': 'Florian√≥polis'
  };
  
  const textoLower = bloco.toLowerCase();
  for (const [key, value] of Object.entries(destinos)) {
    if (textoLower.includes(key)) {
      return value;
    }
  }
  
  // Tentar extrair do padr√£o "S√£o Paulo - [Destino]"
  const padraoDestino = /s√£o paulo\s*[-‚Äì]\s*([^\n\r]+)/i;
  const match = bloco.match(padraoDestino);
  if (match) {
    return match[1].trim();
  }
  
  return 'Destino';
}

function extrairValorDoBloco(bloco) {
  const padraoValor = /R\$\s*([\d.,]+)/i;
  const match = bloco.match(padraoValor);
  return match ? match[0] : 'R$ 0,00';
}

function extrairDataIda(bloco) {
  const padraoData = /(\d{1,2})\s*de\s*(dez|jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov)/i;
  const match = bloco.match(padraoData);
  if (match) {
    const dia = match[1].padStart(2, '0');
    const mesMap = {
      'jan': '01', 'fev': '02', 'mar': '03', 'abr': '04',
      'mai': '05', 'jun': '06', 'jul': '07', 'ago': '08',
      'set': '09', 'out': '10', 'nov': '11', 'dez': '12'
    };
    const mes = mesMap[match[2].toLowerCase()];
    return `${dia}/${mes}`;
  }
  return '19/12';
}

function extrairDataVolta(bloco) {
  const todasDatas = bloco.match(/(\d{1,2})\s*de\s*(dez|jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov)/gi);
  if (todasDatas && todasDatas.length > 1) {
    const match = todasDatas[todasDatas.length - 1].match(/(\d{1,2})\s*de\s*(\w+)/i);
    if (match) {
      const dia = match[1].padStart(2, '0');
      const mesMap = {
        'jan': '01', 'fev': '02', 'mar': '03', 'abr': '04',
        'mai': '05', 'jun': '06', 'jul': '07', 'ago': '08',
        'set': '09', 'out': '10', 'nov': '11', 'dez': '12'
      };
      const mes = mesMap[match[2].toLowerCase()];
      return `${dia}/${mes}`;
    }
  }
  return '26/12';
}

function extrairHorario(bloco, tipo) {
  const horarios = bloco.match(/\d{2}:\d{2}/g) || [];
  
  switch(tipo) {
    case 'ida': return horarios[0] || '07:00';
    case 'chegada_ida': return horarios[1] || '09:00';
    case 'volta': return horarios[2] || '20:00';
    case 'chegada_volta': return horarios[3] || '22:00';
    default: return '00:00';
  }
}

function extrairBagagem(bloco) {
  if (bloco.toLowerCase().includes('2 bagagen') || bloco.toLowerCase().includes('duas bagagen')) {
    return 'Mala de m√£o + 2 bagagens despachadas';
  }
  if (bloco.toLowerCase().includes('bagagem despachada')) {
    return 'Mala de m√£o + bagagem despachada';
  }
  return 'S√≥ mala de m√£o inclu√≠da';
}

function extrairReembolso(bloco) {
  if (bloco.toLowerCase().includes('reembols√°vel conforme')) {
    return 'Reembols√°vel conforme regras do bilhete';
  }
  if (bloco.toLowerCase().includes('n√£o reembols√°vel')) {
    return 'N√£o reembols√°vel';
  }
  return 'N√£o reembols√°vel';
}

function extrairAeroportoDestino(bloco) {
  const aeroportos = {
    'ssa': 'Salvador',
    'bps': 'Porto Seguro',
    'for': 'Fortaleza',
    'rec': 'Recife',
    'nat': 'Natal',
    'mcz': 'Macei√≥'
  };
  
  const textoLower = bloco.toLowerCase();
  for (const [codigo, nome] of Object.entries(aeroportos)) {
    if (textoLower.includes(codigo)) {
      return nome;
    }
  }
  
  return extrairDestinoDoBloco(bloco);
}

// ================================================================================
// 2Ô∏è‚É£ REMO√á√ÉO DE CABE√áALHOS T√âCNICOS
// ================================================================================

function removerCabecalhosTecnicos(conteudo) {
  console.log("üßπ [2] Removendo cabe√ßalhos t√©cnicos...");
  let limpo = conteudo;
  
  const padroesRemover = [
    /^OR√áAMENTO CVC ITAQUA[^\n]*\n?/gim,
    /^SISTEMA PROFISSIONAL[^\n]*\n?/gim,
    /^\*\*Or√ßamento CVC[^\n]*\*\*\n?/gim,
    /^\*\*Passageiro\(s\):[^\n]*\*\*\n?/gim,
    /^---+\n?/gm,
    /^###[^\n]*\n?/gm,
    /^\*\*Observa√ß√µes:\*\*[^\n]*\n?/gim,
    /^TIPOS SELECIONADOS:[^\n]*\n?/gim,
    /^DADOS DA VIAGEM:[^\n]*\n?/gim,
    /^INFORMA√á√ïES ADICIONAIS:[^\n]*\n?/gim,
    /^DEBUG:[^\n]*\n?/gim
  ];
  
  padroesRemover.forEach(padrao => {
    limpo = limpo.replace(padrao, '');
  });
  
  // Remover markdown
  limpo = limpo.replace(/\*\*(.*?)\*\*/g, '*$1*'); // Converter ** para *
  limpo = limpo.replace(/^#+\s*/gm, ''); // Remover headers markdown
  limpo = limpo.replace(/^-\s+/gm, '‚Ä¢ '); // Converter listas
  
  return limpo.trim();
}

// ================================================================================
// 3Ô∏è‚É£ FORMATA√á√ÉO COMPLETA E PROFISSIONAL
// ================================================================================

function aplicarFormatacaoCompleta(conteudo) {
  console.log("üé® [3] Aplicando formata√ß√£o completa...");
  let formatado = conteudo;
  
  // Convers√£o COMPLETA de c√≥digos de aeroporto
  const codigosAeroporto = {
    'GRU': 'Guarulhos',
    'CGH': 'Congonhas',
    'VCP': 'Viracopos',
    'SSA': 'Salvador',
    'BPS': 'Porto Seguro',
    'SDU': 'Santos Dumont',
    'GIG': 'Gale√£o',
    'BSB': 'Bras√≠lia',
    'CNF': 'Confins',
    'POA': 'Porto Alegre',
    'CWB': 'Curitiba',
    'FOR': 'Fortaleza',
    'REC': 'Recife',
    'NAT': 'Natal',
    'MCZ': 'Macei√≥',
    'FLN': 'Florian√≥polis',
    'MAO': 'Manaus',
    'BEL': 'Bel√©m'
  };
  
  // Aplicar convers√µes
  Object.entries(codigosAeroporto).forEach(([codigo, nome]) => {
    const regex = new RegExp(`\\b${codigo}\\b`, 'gi');
    formatado = formatado.replace(regex, nome);
  });
  
  // Formata√ß√£o de valores monet√°rios (manter formato brasileiro)
  formatado = formatado.replace(/R\$\s*(\d+)\.(\d{3}),(\d{2})/g, 'R$ $1.$2,$3');
  formatado = formatado.replace(/R\$\s*(\d+),(\d{2})/g, 'R$ $1,$2');
  
  // Formata√ß√£o de datas
  formatado = formatado.replace(/(\d{1,2})[\/\-](\d{1,2})/g, (match, dia, mes) => {
    return `${dia.padStart(2, '0')}/${mes.padStart(2, '0')}`;
  });
  
  // Formata√ß√£o de hor√°rios (remover espa√ßos extras)
  formatado = formatado.replace(/(\d{1,2})\s*:\s*(\d{2})/g, (match, h, m) => {
    return `${h.padStart(2, '0')}:${m}`;
  });
  
  // Limpeza de espa√ßos
  formatado = formatado.replace(/\n{3,}/g, '\n\n');
  formatado = formatado.replace(/[ \t]+\n/g, '\n');
  formatado = formatado.replace(/\n[ \t]+/g, '\n');
  
  return formatado.trim();
}

// ================================================================================
// 4Ô∏è‚É£ VALIDA√á√ÉO DE REGRAS CR√çTICAS
// ================================================================================

function validarRegrasCriticas(conteudo) {
  console.log("‚úÖ [4] Validando regras cr√≠ticas CVC...");
  let validado = conteudo;
  
  // Garantir formato de hor√°rio correto
  validado = validado.replace(/(\d{1,2})\s*:\s*(\d{2})/g, '$1:$2');
  
  // Garantir espa√ßo ap√≥s R$
  validado = validado.replace(/R\$(\d)/g, 'R$ $1');
  
  // Garantir formato de passageiros com zero √† esquerda
  validado = validado.replace(/\b(\d)\s+adulto/gi, (match, num) => {
    return `${num.padStart(2, '0')} adulto`;
  });
  
  // Garantir separador -- entre ida e volta
  if (!validado.includes('--')) {
    validado = validado.replace(/(volta|retorno):/gi, '--\n$1:');
  }
  
  return validado;
}

// ================================================================================
// 5Ô∏è‚É£ CORRE√á√ïES ESPEC√çFICAS POR TIPO
// ================================================================================

function aplicarCorrecoesPorTipo(conteudo, analise) {
  console.log("üîß [5] Aplicando corre√ß√µes por tipo:", analise?.tipoDetectado || analise?.tipo_principal);
  let corrigido = conteudo;
  
  const tipo = (analise?.tipoDetectado || analise?.tipo_principal || '').toLowerCase();
  
  switch (tipo) {
    case 'multiplas_opcoes_2':
    case 'multiplas_opcoes_3':
      corrigido = garantirFormatoMultiplasOpcoes(corrigido);
      break;
      
    case 'aereo_nacional_simples':
    case 'a√©reo nacional':
    case 'a√©reo internacional':
      corrigido = processarOrcamentoAereo(corrigido, analise);
      break;
      
    case 'cruzeiro':
    case 'cruzeiros':
      corrigido = processarOrcamentoCruzeiro(corrigido, analise);
      break;
      
    case 'hotel':
    case 'hot√©is':
      corrigido = processarOrcamentoHotel(corrigido, analise);
      break;
      
    case 'pacote':
    case 'pacotes':
    case 'pacote_completo':
      corrigido = processarOrcamentoPacote(corrigido, analise);
      break;
  }
  
  return corrigido;
}

function garantirFormatoMultiplasOpcoes(conteudo) {
  console.log("üî¢ [5] Garantindo formato de m√∫ltiplas op√ß√µes...");
  
  // Garantir que OP√á√ÉO esteja em mai√∫sculas e com asterisco
  conteudo = conteudo.replace(/op√ß√£o\s+(\d)/gi, '*OP√á√ÉO $1*');
  
  // Garantir separa√ß√£o entre op√ß√µes
  conteudo = conteudo.replace(/(\*OP√á√ÉO \d\*)/g, '\n$1');
  
  return conteudo;
}

function processarOrcamentoAereo(conteudo, analise) {
  console.log("‚úàÔ∏è [5] Processando or√ßamento a√©reo...");
  let processado = conteudo;
  
  // Garantir emoji de avi√£o se n√£o houver
  if (!processado.match(/[‚úàÔ∏èüõ´]/)) {
    const primeiraLinha = processado.split('\n')[0];
    if (primeiraLinha.includes('*')) {
      processado = processado.replace(primeiraLinha, primeiraLinha.replace('*', '*‚úàÔ∏è '));
    }
  }
  
  return processado;
}

function processarOrcamentoCruzeiro(conteudo, analise) {
  console.log("üö¢ [5] Processando or√ßamento de cruzeiro...");
  return conteudo.startsWith('üö¢') ? conteudo : 'üö¢ ' + conteudo;
}

function processarOrcamentoHotel(conteudo, analise) {
  console.log("üè® [5] Processando or√ßamento de hotel...");
  return conteudo.match(/^[üè®üè©]/) ? conteudo : 'üè® ' + conteudo;
}

function processarOrcamentoPacote(conteudo, analise) {
  console.log("üèñÔ∏è [5] Processando or√ßamento de pacote...");
  return conteudo.match(/^[üèñÔ∏èüì¶]/) ? conteudo : 'üèñÔ∏è ' + conteudo;
}

// ================================================================================
// üîü GARANTIR FORMATO WHATSAPP
// ================================================================================

function garantirFormatoWhatsApp(conteudo) {
  console.log("üì± [10] Garantindo formato WhatsApp...");
  let formatado = conteudo;
  
  // REMOVER qualquer formato markdown restante
  formatado = formatado.replace(/#{1,6}\s*/g, ''); // Headers
  formatado = formatado.replace(/\*\*(.*?)\*\*/g, '*$1*'); // Bold
  formatado = formatado.replace(/__(.*?)__/g, '$1'); // Underline
  formatado = formatado.replace(/\[(.*?)\]\(.*?\)/g, '$1'); // Links
  formatado = formatado.replace(/^>\s*/gm, ''); // Quotes
  formatado = formatado.replace(/```[^`]*```/g, ''); // Code blocks
  formatado = formatado.replace(/`([^`]+)`/g, '$1'); // Inline code
  
  // Garantir emojis apropriados
  if (!formatado.match(/[üí∞üí≥‚úÖüè∑Ô∏èüìÖüë•üéØüìç‚úàÔ∏èüö¢üè®]/)) {
    console.log("‚ö†Ô∏è [10] Adicionando emojis faltantes...");
    
    // Adicionar emojis em linhas espec√≠ficas
    formatado = formatado.replace(/^(R\$\s*[\d.,]+)/gm, 'üí∞ $1');
    formatado = formatado.replace(/\b(parcel\w+|cart√£o)/gi, 'üí≥ $&');
    formatado = formatado.replace(/\b(bagagem|mala)/gi, '‚úÖ $&');
    formatado = formatado.replace(/\b(n√£o\s+reembols√°vel|reembols√°vel)/gi, 'üè∑Ô∏è $&');
  }
  
  return formatado;
}

// ================================================================================
// 6Ô∏è‚É£ FORMATA√á√ÉO FINAL PARA WHATSAPP
// ================================================================================

function formatarParaWhatsApp(conteudo) {
  console.log("üì± [6] Formata√ß√£o final para WhatsApp...");
  let formatado = conteudo;
  
  // Garantir quebras de linha adequadas
  formatado = formatado.replace(/\n{3,}/g, '\n\n');
  
  // Remover espa√ßos em excesso
  formatado = formatado.replace(/\s+\n/g, '\n');
  formatado = formatado.replace(/\n\s+/g, '\n');
  
  // Garantir formata√ß√£o de t√≠tulos com asterisco
  formatado = formatado.replace(/^([A-Z√Å√â√ç√ì√ö√Ä√à√å√í√ô√Ç√ä√é√î√õ√É√ï√á\s]+):$/gm, '*$1:*');
  
  // Garantir espa√ßamento entre se√ß√µes
  formatado = formatado.replace(/\n([üí∞‚úÖüè∑Ô∏èüìÖüë•])/g, '\n$1');
  
  return formatado.trim();
}

// ================================================================================
// 7Ô∏è‚É£ VALIDA√á√ÉO FINAL DO OR√áAMENTO
// ================================================================================

function validarOrcamentoFinal(conteudo, formData) {
  console.log("‚úÖ [7] Executando valida√ß√£o final...");
  
  const problemas = [];
  
  // Verifica√ß√µes obrigat√≥rias
  if (!conteudo.includes('R$')) {
    problemas.push('Valor em reais n√£o encontrado');
  }
  
  if (!/\d{2}:\d{2}/.test(conteudo)) {
    problemas.push('Hor√°rios n√£o encontrados');
  }
  
  if (!/\d{2}\/\d{2}/.test(conteudo)) {
    problemas.push('Datas n√£o encontradas');
  }
  
  // Verificar elementos essenciais do formato CVC
  if (!conteudo.includes('*')) {
    problemas.push('Formata√ß√£o com asterisco n√£o encontrada');
  }
  
  if (!conteudo.match(/[üí∞‚úÖüè∑Ô∏è]/)) {
    problemas.push('Emojis padr√£o CVC n√£o encontrados');
  }
  
  const validacao = {
    valido: problemas.length === 0,
    problemas: problemas,
    score: (5 - problemas.length) / 5 * 100
  };
  
  if (problemas.length > 0) {
    console.log(`‚ö†Ô∏è [7] Problemas encontrados: ${problemas.join(', ')}`);
  } else {
    console.log("‚úÖ [7] Valida√ß√£o perfeita! Score: 100%");
  }
  
  return validacao;
}

// ================================================================================
// 8Ô∏è‚É£ M√âTRICAS DE QUALIDADE
// ================================================================================

function calcularMetricasQualidade(conteudoOriginal, conteudoProcessado) {
  console.log("üìä [8] Calculando m√©tricas de qualidade...");
  
  const metricas = {
    conversoes: {
      aeroportos_convertidos: contarConversoesAeroportos(conteudoOriginal, conteudoProcessado),
      markdown_removido: contarMarkdownRemovido(conteudoOriginal, conteudoProcessado),
      emojis_adicionados: contarEmojisAdicionados(conteudoProcessado)
    },
    qualidade: {
      tem_valores: conteudoProcessado.includes('R$'),
      tem_horarios: /\d{2}:\d{2}/.test(conteudoProcessado),
      tem_datas: /\d{2}\/\d{2}/.test(conteudoProcessado),
      formato_whatsapp: !conteudoProcessado.includes('**') && !conteudoProcessado.includes('##'),
      emojis_presentes: (conteudoProcessado.match(/[üí∞‚úÖüè∑Ô∏èüì±‚ö†Ô∏è‚úàÔ∏èüö¢üè®]/g) || []).length,
      tem_opcoes_multiplas: /OP√á√ÉO \d/.test(conteudoProcessado)
    },
    tamanho: {
      original: conteudoOriginal.length,
      processado: conteudoProcessado.length,
      reducao_percentual: ((conteudoOriginal.length - conteudoProcessado.length) / conteudoOriginal.length * 100).toFixed(1)
    }
  };
  
  // Calcular score geral
  const scores = Object.values(metricas.qualidade);
  const scoreTotal = scores.filter(Boolean).length / scores.length * 100;
  metricas.score_geral = scoreTotal.toFixed(1);
  
  console.log(`üìä [8] Score de qualidade: ${metricas.score_geral}%`);
  return metricas;
}

function contarConversoesAeroportos(original, processado) {
  const codigos = ['GRU', 'CGH', 'SSA', 'BPS', 'BSB', 'POA'];
  let conversoes = 0;
  
  codigos.forEach(codigo => {
    if (original.includes(codigo) && !processado.includes(codigo)) {
      conversoes++;
    }
  });
  
  return conversoes;
}

function contarMarkdownRemovido(original, processado) {
  const markdownPatterns = [/\*\*/g, /##/g, /```/g, /__/g];
  let removidos = 0;
  
  markdownPatterns.forEach(pattern => {
    const originalCount = (original.match(pattern) || []).length;
    const processadoCount = (processado.match(pattern) || []).length;
    removidos += originalCount - processadoCount;
  });
  
  return removidos;
}

function contarEmojisAdicionados(conteudo) {
  return (conteudo.match(/[üí∞‚úÖüè∑Ô∏èüì±‚ö†Ô∏è‚úàÔ∏èüö¢üè®üìÖüë•üéØüìç]/g) || []).length;
}

// ================================================================================
// üé® FORMATA√á√ÉO B√ÅSICA - FALLBACK
// ================================================================================

function aplicarFormatacaoBasica(conteudo) {
  console.log("üé® [FB] Aplicando formata√ß√£o b√°sica (fallback)...");
  
  let basico = conteudo;
  
  // Formata√ß√£o m√≠nima essencial
  basico = basico.replace(/R\$\s*(\d+)/g, 'R$ $1,00');
  basico = basico.replace(/\n{3,}/g, '\n\n');
  basico = basico.replace(/\*\*(.*?)\*\*/g, '*$1*');
  
  // Adicionar emojis b√°sicos se n√£o houver
  if (!basico.includes('üí∞')) {
    basico = basico.replace(/(R\$\s*[\d.,]+)/g, 'üí∞ $1');
  }
  
  return basico.trim();
}

// ================================================================================
// üöÄ EXPORTA√á√ÉO ES6 - v9.1 COMPLETA
// ================================================================================

console.log("‚úÖ Processing v9.1 carregado com sucesso!");
console.log("üéØ Funcionalidades ativas:");
console.log("- ‚úÖ Processamento de m√∫ltiplas op√ß√µes");
console.log("- ‚úÖ Formata√ß√£o WhatsApp garantida");
console.log("- ‚úÖ Convers√£o completa de aeroportos");
console.log("- ‚úÖ Valida√ß√£o CVC rigorosa");
console.log("- ‚úÖ M√©tricas de qualidade");
console.log("- ‚úÖ Extra√ß√£o correta de datas e hor√°rios");
console.log("- ‚úÖ Extra√ß√£o correta de passageiros (4 adultos)");

// Exporta√ß√£o nomeada
export {
  processarRespostaCompleta,
  aplicarFormatacaoCompleta,
  validarOrcamentoFinal,
  formatarParaWhatsApp,
  calcularMetricasQualidade,
  processarMultiplasOpcoes,
  garantirFormatoWhatsApp,
  extrairDatasVoo,
  corrigirDatasHorariosPassageiros
};

// Exporta√ß√£o default
export default {
  processarRespostaCompleta,
  aplicarFormatacaoCompleta,
  validarOrcamentoFinal,
  formatarParaWhatsApp,
  calcularMetricasQualidade,
  processarMultiplasOpcoes,
  garantirFormatoWhatsApp,
  extrairDatasVoo,
  corrigirDatasHorariosPassageiros
};

console.log("üöÄ Sistema de Processamento v9.1 - CORRIGIDO PARA CVC ITAQUA!");
